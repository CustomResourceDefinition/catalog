{
  "description": "SecretTemplate allows the construction of secrets using data that reside in other Kubernetes resources",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "SecretTemplateSpec contains spec information",
      "type": "object",
      "required": [
        "inputResources"
      ],
      "properties": {
        "inputResources": {
          "description": "A list of input resources that are used to construct a new secret. Input Resources can refer to ANY Kubernetes API. If loading more than Secrets types ensure that `.spec.ServiceAccountName` is set to an appropriate value. Input resources are read in the order they are defined. An Input resource's name can be evaluated dynamically from data in a previously evaluated input resource.",
          "type": "array",
          "items": {
            "description": "InputResource is references a single Kubernetes resource along with a identifying name",
            "type": "object",
            "required": [
              "name",
              "ref"
            ],
            "properties": {
              "name": {
                "description": "The name of InputResource. This is used as the identifying name in templating to refer to this Input Resource.",
                "type": "string"
              },
              "ref": {
                "description": "The reference to the Input Resource",
                "type": "object",
                "required": [
                  "apiVersion",
                  "kind",
                  "name"
                ],
                "properties": {
                  "apiVersion": {
                    "type": "string"
                  },
                  "kind": {
                    "type": "string"
                  },
                  "name": {
                    "description": "The name of the input resource. This field can itself contain JSONPATH syntax to load the name dynamically from other input resources. For example this field could be set to a static value of \"my-secret\" or a dynamic valid of \"$(.anotherinputresource.spec.name)\".",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        },
        "serviceAccountName": {
          "description": "The Service Account used to read InputResources. If not specified, only Secrets can be read as InputResources.",
          "type": "string"
        },
        "template": {
          "description": "A JSONPath based template that can be used to create Secrets.",
          "type": "object",
          "properties": {
            "data": {
              "description": "Data key and value. Where key is the Secret Key and the value is a jsonpath surrounded by $( ). The fetched data MUST be base64 encoded. All InputResources are available via their identifying name. For example: key1: $(.secretinput1.data.value1) key2: $(.secretinput2.data.value2)",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "metadata": {
              "description": "Metadata contains metadata for the Secret",
              "type": "object",
              "properties": {
                "annotations": {
                  "description": "Annotations to be placed on the generated secret",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "description": "Labels to be placed on the generated secret",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              },
              "additionalProperties": false
            },
            "stringData": {
              "description": "StringData key and value. Where key is the Secret Key and the value can contain a JSONPATH syntax surrounded by $( ). All InputResources are available via their identifying name. For example: key1: static-text key2: $(.input1.spec.value1) key3: combined-$(.input2.status.value2)-$(.input2.status.value3)",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "type": {
              "description": "Type is the type of Kubernetes Secret",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "status": {
      "description": "SecretTemplateStatus contains status information",
      "type": "object",
      "properties": {
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "message": {
                "description": "Human-readable message indicating details about last transition.",
                "type": "string"
              },
              "reason": {
                "description": "Unique, this should be a short, machine understandable string that gives the reason for condition's last transition. If it reports \"ResizeStarted\" that means the underlying persistent volume is being resized.",
                "type": "string"
              },
              "status": {
                "type": "string"
              },
              "type": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "friendlyDescription": {
          "type": "string"
        },
        "observedGeneration": {
          "type": "integer",
          "format": "int64"
        },
        "observedSecretResourceVersion": {
          "type": "string"
        },
        "secret": {
          "description": "LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.",
          "type": "object",
          "properties": {
            "name": {
              "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?",
              "type": "string"
            }
          },
          "additionalProperties": false,
          "x-kubernetes-map-type": "atomic"
        }
      },
      "additionalProperties": false
    }
  }
}
