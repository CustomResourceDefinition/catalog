{
  "description": "SecretBackendSign is the Schema for the SecretBackendSigns API. Sign a new certificate based on the CSR by the PKI.",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "SecretBackendSignSpec defines the desired state of SecretBackendSign",
      "type": "object",
      "required": [
        "forProvider"
      ],
      "properties": {
        "forProvider": {
          "type": "object",
          "properties": {
            "altNames": {
              "description": "List of alternative names\nList of alternative names.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "autoRenew": {
              "description": "If set to true, certs will be renewed if the expiration is within min_seconds_remaining. Default false\nIf enabled, a new certificate will be generated if the expiration is within min_seconds_remaining",
              "type": "boolean"
            },
            "backend": {
              "description": "The PKI secret backend the resource belongs to.\nThe PKI secret backend the resource belongs to.",
              "type": "string"
            },
            "backendRef": {
              "description": "Reference to a Mount in vault to populate backend.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referenced object",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "backendSelector": {
              "description": "Selector for a Mount in vault to populate backend.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "namespace": {
                  "description": "Namespace for the selector",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "certMetadata": {
              "description": "A base 64 encoded value or an empty string to associate with the certificate's serial number. The role's no_store_metadata must be set to false, otherwise an error is returned when specified.\nA base 64 encoded value or an empty string to associate with the certificate's serial number. The role's no_store_metadata must be set to false, otherwise an error is returned when specified.",
              "type": "string"
            },
            "commonName": {
              "description": "CN of certificate to create\nCN of intermediate to create.",
              "type": "string"
            },
            "csr": {
              "description": "The CSR\nThe CSR.",
              "type": "string"
            },
            "excludeCnFromSans": {
              "description": "Flag to exclude CN from SANs\nFlag to exclude CN from SANs.",
              "type": "boolean"
            },
            "format": {
              "description": "The format of data\nThe format of data.",
              "type": "string"
            },
            "ipSans": {
              "description": "List of alternative IPs\nList of alternative IPs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "issuerRef": {
              "description": "Specifies the default issuer of this request. Can\nbe the value default, a name, or an issuer ID. Use ACLs to prevent access to\nthe /pki/issuer/:issuer_ref/{issue,sign}/:name paths to prevent users\noverriding the role's issuer_ref value.\nSpecifies the default issuer of this request.",
              "type": "string"
            },
            "minSecondsRemaining": {
              "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\nGenerate a new certificate when the expiration is within this number of seconds",
              "type": "number"
            },
            "name": {
              "description": "Name of the role to create the certificate against\nName of the role to create the certificate against.",
              "type": "string"
            },
            "nameRef": {
              "description": "Reference to a SecretBackendRole in pki to populate name.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referenced object",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "nameSelector": {
              "description": "Selector for a SecretBackendRole in pki to populate name.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "namespace": {
                  "description": "Namespace for the selector",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "notAfter": {
              "description": "Set the Not After field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z.\nSet the Not After field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z.",
              "type": "string"
            },
            "otherSans": {
              "description": "List of other SANs\nList of other SANs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "ttl": {
              "description": "Time to live\nTime to live.",
              "type": "string"
            },
            "uriSans": {
              "description": "List of alternative URIs\nList of alternative URIs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        },
        "initProvider": {
          "description": "THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.",
          "type": "object",
          "properties": {
            "altNames": {
              "description": "List of alternative names\nList of alternative names.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "autoRenew": {
              "description": "If set to true, certs will be renewed if the expiration is within min_seconds_remaining. Default false\nIf enabled, a new certificate will be generated if the expiration is within min_seconds_remaining",
              "type": "boolean"
            },
            "backend": {
              "description": "The PKI secret backend the resource belongs to.\nThe PKI secret backend the resource belongs to.",
              "type": "string"
            },
            "backendRef": {
              "description": "Reference to a Mount in vault to populate backend.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referenced object",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "backendSelector": {
              "description": "Selector for a Mount in vault to populate backend.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "namespace": {
                  "description": "Namespace for the selector",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "certMetadata": {
              "description": "A base 64 encoded value or an empty string to associate with the certificate's serial number. The role's no_store_metadata must be set to false, otherwise an error is returned when specified.\nA base 64 encoded value or an empty string to associate with the certificate's serial number. The role's no_store_metadata must be set to false, otherwise an error is returned when specified.",
              "type": "string"
            },
            "commonName": {
              "description": "CN of certificate to create\nCN of intermediate to create.",
              "type": "string"
            },
            "csr": {
              "description": "The CSR\nThe CSR.",
              "type": "string"
            },
            "excludeCnFromSans": {
              "description": "Flag to exclude CN from SANs\nFlag to exclude CN from SANs.",
              "type": "boolean"
            },
            "format": {
              "description": "The format of data\nThe format of data.",
              "type": "string"
            },
            "ipSans": {
              "description": "List of alternative IPs\nList of alternative IPs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "issuerRef": {
              "description": "Specifies the default issuer of this request. Can\nbe the value default, a name, or an issuer ID. Use ACLs to prevent access to\nthe /pki/issuer/:issuer_ref/{issue,sign}/:name paths to prevent users\noverriding the role's issuer_ref value.\nSpecifies the default issuer of this request.",
              "type": "string"
            },
            "minSecondsRemaining": {
              "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\nGenerate a new certificate when the expiration is within this number of seconds",
              "type": "number"
            },
            "name": {
              "description": "Name of the role to create the certificate against\nName of the role to create the certificate against.",
              "type": "string"
            },
            "nameRef": {
              "description": "Reference to a SecretBackendRole in pki to populate name.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referenced object",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "nameSelector": {
              "description": "Selector for a SecretBackendRole in pki to populate name.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "namespace": {
                  "description": "Namespace for the selector",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "notAfter": {
              "description": "Set the Not After field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z.\nSet the Not After field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z.",
              "type": "string"
            },
            "otherSans": {
              "description": "List of other SANs\nList of other SANs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "ttl": {
              "description": "Time to live\nTime to live.",
              "type": "string"
            },
            "uriSans": {
              "description": "List of alternative URIs\nList of alternative URIs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        },
        "managementPolicies": {
          "description": "THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md",
          "type": "array",
          "default": [
            "*"
          ],
          "items": {
            "description": "A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.",
            "type": "string",
            "enum": [
              "Observe",
              "Create",
              "Update",
              "Delete",
              "LateInitialize",
              "*"
            ]
          }
        },
        "providerConfigRef": {
          "description": "ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.",
          "type": "object",
          "default": {
            "kind": "ClusterProviderConfig",
            "name": "default"
          },
          "required": [
            "kind",
            "name"
          ],
          "properties": {
            "kind": {
              "description": "Kind of the referenced object.",
              "type": "string"
            },
            "name": {
              "description": "Name of the referenced object.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "writeConnectionSecretToRef": {
          "description": "WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.",
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "Name of the secret.",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "x-kubernetes-validations": [
        {
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.commonName) || (has(self.initProvider) \u0026\u0026 has(self.initProvider.commonName))",
          "message": "spec.forProvider.commonName is a required parameter"
        },
        {
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.csr) || (has(self.initProvider) \u0026\u0026 has(self.initProvider.csr))",
          "message": "spec.forProvider.csr is a required parameter"
        }
      ]
    },
    "status": {
      "description": "SecretBackendSignStatus defines the observed state of SecretBackendSign.",
      "type": "object",
      "properties": {
        "atProvider": {
          "type": "object",
          "properties": {
            "altNames": {
              "description": "List of alternative names\nList of alternative names.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "autoRenew": {
              "description": "If set to true, certs will be renewed if the expiration is within min_seconds_remaining. Default false\nIf enabled, a new certificate will be generated if the expiration is within min_seconds_remaining",
              "type": "boolean"
            },
            "backend": {
              "description": "The PKI secret backend the resource belongs to.\nThe PKI secret backend the resource belongs to.",
              "type": "string"
            },
            "caChain": {
              "description": "The CA chain\nThe CA chain.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "certMetadata": {
              "description": "A base 64 encoded value or an empty string to associate with the certificate's serial number. The role's no_store_metadata must be set to false, otherwise an error is returned when specified.\nA base 64 encoded value or an empty string to associate with the certificate's serial number. The role's no_store_metadata must be set to false, otherwise an error is returned when specified.",
              "type": "string"
            },
            "certificate": {
              "description": "The certificate\nThe certicate.",
              "type": "string"
            },
            "commonName": {
              "description": "CN of certificate to create\nCN of intermediate to create.",
              "type": "string"
            },
            "csr": {
              "description": "The CSR\nThe CSR.",
              "type": "string"
            },
            "excludeCnFromSans": {
              "description": "Flag to exclude CN from SANs\nFlag to exclude CN from SANs.",
              "type": "boolean"
            },
            "expiration": {
              "description": "The expiration date of the certificate in unix epoch format\nThe certificate expiration as a Unix-style timestamp.",
              "type": "number"
            },
            "format": {
              "description": "The format of data\nThe format of data.",
              "type": "string"
            },
            "id": {
              "type": "string"
            },
            "ipSans": {
              "description": "List of alternative IPs\nList of alternative IPs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "issuerRef": {
              "description": "Specifies the default issuer of this request. Can\nbe the value default, a name, or an issuer ID. Use ACLs to prevent access to\nthe /pki/issuer/:issuer_ref/{issue,sign}/:name paths to prevent users\noverriding the role's issuer_ref value.\nSpecifies the default issuer of this request.",
              "type": "string"
            },
            "issuingCa": {
              "description": "The issuing CA\nThe issuing CA.",
              "type": "string"
            },
            "minSecondsRemaining": {
              "description": "Generate a new certificate when the expiration is within this number of seconds, default is 604800 (7 days)\nGenerate a new certificate when the expiration is within this number of seconds",
              "type": "number"
            },
            "name": {
              "description": "Name of the role to create the certificate against\nName of the role to create the certificate against.",
              "type": "string"
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "notAfter": {
              "description": "Set the Not After field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z.\nSet the Not After field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ. Supports the Y10K end date for IEEE 802.1AR-2018 standard devices, 9999-12-31T23:59:59Z.",
              "type": "string"
            },
            "otherSans": {
              "description": "List of other SANs\nList of other SANs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "renewPending": {
              "description": "true if the current time (during refresh) is after the start of the early renewal window declared by min_seconds_remaining, and false otherwise; if auto_renew is set to true then the provider will plan to replace the certificate once renewal is pending.\nInitially false, and then set to true during refresh once the expiration is less than min_seconds_remaining in the future.",
              "type": "boolean"
            },
            "serialNumber": {
              "description": "The certificate's serial number, hex formatted.\nThe certificate's serial number, hex formatted.",
              "type": "string"
            },
            "ttl": {
              "description": "Time to live\nTime to live.",
              "type": "string"
            },
            "uriSans": {
              "description": "List of alternative URIs\nList of alternative URIs.",
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        },
        "conditions": {
          "description": "Conditions of the resource.",
          "type": "array",
          "items": {
            "description": "A Condition that may apply to a resource.",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "LastTransitionTime is the last time this condition transitioned from one\nstatus to another.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "A Message containing details about this condition's last transition from\none status to another, if any.",
                "type": "string"
              },
              "observedGeneration": {
                "description": "ObservedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "type": "integer",
                "format": "int64"
              },
              "reason": {
                "description": "A Reason for this condition's last transition from one status to another.",
                "type": "string"
              },
              "status": {
                "description": "Status of this condition; is it currently True, False, or Unknown?",
                "type": "string"
              },
              "type": {
                "description": "Type of this condition. At most one of each condition type may apply to\na resource at any point in time.",
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the latest metadata.generation\nwhich resulted in either a ready state, or stalled due to error\nit can not recover from without human intervention.",
          "type": "integer",
          "format": "int64"
        }
      },
      "additionalProperties": false
    }
  }
}
