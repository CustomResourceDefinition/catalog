{
  "description": "KubeadmControlPlane is the Schema for the KubeadmControlPlane API.\n\nDeprecated: This type will be removed in one of the next releases.",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "spec is the desired state of KubeadmControlPlane.",
      "type": "object",
      "required": [
        "kubeadmConfigSpec",
        "machineTemplate",
        "version"
      ],
      "properties": {
        "kubeadmConfigSpec": {
          "description": "kubeadmConfigSpec is a KubeadmConfigSpec\nto use for initializing and joining machines to the control plane.",
          "type": "object",
          "properties": {
            "clusterConfiguration": {
              "description": "clusterConfiguration along with InitConfiguration are the configurations necessary for the init command",
              "type": "object",
              "properties": {
                "apiServer": {
                  "description": "apiServer contains extra settings for the API server control plane component",
                  "type": "object",
                  "properties": {
                    "certSANs": {
                      "description": "certSANs sets extra Subject Alternative Names for the API Server signing cert.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "extraArgs": {
                      "description": "extraArgs is an extra set of flags to pass to the control plane component.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "extraVolumes": {
                      "description": "extraVolumes is an extra set of host volumes, mounted to the control plane component.",
                      "type": "array",
                      "items": {
                        "description": "HostPathMount contains elements describing volumes that are mounted from the\nhost.",
                        "type": "object",
                        "required": [
                          "hostPath",
                          "mountPath",
                          "name"
                        ],
                        "properties": {
                          "hostPath": {
                            "description": "hostPath is the path in the host that will be mounted inside\nthe pod.",
                            "type": "string"
                          },
                          "mountPath": {
                            "description": "mountPath is the path inside the pod where hostPath will be mounted.",
                            "type": "string"
                          },
                          "name": {
                            "description": "name of the volume inside the pod template.",
                            "type": "string"
                          },
                          "pathType": {
                            "description": "pathType is the type of the HostPath.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly controls write access to the volume",
                            "type": "boolean"
                          }
                        },
                        "additionalProperties": false
                      }
                    },
                    "timeoutForControlPlane": {
                      "description": "timeoutForControlPlane controls the timeout that we use for API server to appear",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                },
                "apiVersion": {
                  "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                  "type": "string"
                },
                "certificatesDir": {
                  "description": "certificatesDir specifies where to store or look for all required certificates.\nNB: if not provided, this will default to `/etc/kubernetes/pki`",
                  "type": "string"
                },
                "clusterName": {
                  "description": "clusterName is the cluster name",
                  "type": "string"
                },
                "controlPlaneEndpoint": {
                  "description": "controlPlaneEndpoint sets a stable IP address or DNS name for the control plane; it\ncan be a valid IP address or a RFC-1123 DNS subdomain, both with optional TCP port.\nIn case the ControlPlaneEndpoint is not specified, the AdvertiseAddress + BindPort\nare used; in case the ControlPlaneEndpoint is specified but without a TCP port,\nthe BindPort is used.\nPossible usages are:\ne.g. In a cluster with more than one control plane instances, this field should be\nassigned the address of the external load balancer in front of the\ncontrol plane instances.\ne.g.  in environments with enforced node recycling, the ControlPlaneEndpoint\ncould be used for assigning a stable DNS to the control plane.\nNB: This value defaults to the first value in the Cluster object status.apiEndpoints array.",
                  "type": "string"
                },
                "controllerManager": {
                  "description": "controllerManager contains extra settings for the controller manager control plane component",
                  "type": "object",
                  "properties": {
                    "extraArgs": {
                      "description": "extraArgs is an extra set of flags to pass to the control plane component.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "extraVolumes": {
                      "description": "extraVolumes is an extra set of host volumes, mounted to the control plane component.",
                      "type": "array",
                      "items": {
                        "description": "HostPathMount contains elements describing volumes that are mounted from the\nhost.",
                        "type": "object",
                        "required": [
                          "hostPath",
                          "mountPath",
                          "name"
                        ],
                        "properties": {
                          "hostPath": {
                            "description": "hostPath is the path in the host that will be mounted inside\nthe pod.",
                            "type": "string"
                          },
                          "mountPath": {
                            "description": "mountPath is the path inside the pod where hostPath will be mounted.",
                            "type": "string"
                          },
                          "name": {
                            "description": "name of the volume inside the pod template.",
                            "type": "string"
                          },
                          "pathType": {
                            "description": "pathType is the type of the HostPath.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly controls write access to the volume",
                            "type": "boolean"
                          }
                        },
                        "additionalProperties": false
                      }
                    }
                  },
                  "additionalProperties": false
                },
                "dns": {
                  "description": "dns defines the options for the DNS add-on installed in the cluster.",
                  "type": "object",
                  "properties": {
                    "imageRepository": {
                      "description": "imageRepository sets the container registry to pull images from.\nif not set, the ImageRepository defined in ClusterConfiguration will be used instead.",
                      "type": "string"
                    },
                    "imageTag": {
                      "description": "imageTag allows to specify a tag for the image.\nIn case this value is set, kubeadm does not change automatically the version of the above components during upgrades.",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                },
                "etcd": {
                  "description": "etcd holds configuration for etcd.\nNB: This value defaults to a Local (stacked) etcd",
                  "type": "object",
                  "properties": {
                    "external": {
                      "description": "external describes how to connect to an external etcd cluster\nLocal and External are mutually exclusive",
                      "type": "object",
                      "required": [
                        "caFile",
                        "certFile",
                        "endpoints",
                        "keyFile"
                      ],
                      "properties": {
                        "caFile": {
                          "description": "caFile is an SSL Certificate Authority file used to secure etcd communication.\nRequired if using a TLS connection.",
                          "type": "string"
                        },
                        "certFile": {
                          "description": "certFile is an SSL certification file used to secure etcd communication.\nRequired if using a TLS connection.",
                          "type": "string"
                        },
                        "endpoints": {
                          "description": "endpoints of etcd members. Required for ExternalEtcd.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "keyFile": {
                          "description": "keyFile is an SSL key file used to secure etcd communication.\nRequired if using a TLS connection.",
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    },
                    "local": {
                      "description": "local provides configuration knobs for configuring the local etcd instance\nLocal and External are mutually exclusive",
                      "type": "object",
                      "properties": {
                        "dataDir": {
                          "description": "dataDir is the directory etcd will place its data.\nDefaults to \"/var/lib/etcd\".",
                          "type": "string"
                        },
                        "extraArgs": {
                          "description": "extraArgs are extra arguments provided to the etcd binary\nwhen run inside a static pod.",
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        },
                        "imageRepository": {
                          "description": "imageRepository sets the container registry to pull images from.\nif not set, the ImageRepository defined in ClusterConfiguration will be used instead.",
                          "type": "string"
                        },
                        "imageTag": {
                          "description": "imageTag allows to specify a tag for the image.\nIn case this value is set, kubeadm does not change automatically the version of the above components during upgrades.",
                          "type": "string"
                        },
                        "peerCertSANs": {
                          "description": "peerCertSANs sets extra Subject Alternative Names for the etcd peer signing cert.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "serverCertSANs": {
                          "description": "serverCertSANs sets extra Subject Alternative Names for the etcd server signing cert.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      },
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                },
                "featureGates": {
                  "description": "featureGates enabled by the user.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "boolean"
                  }
                },
                "imageRepository": {
                  "description": "imageRepository sets the container registry to pull images from.\nIf empty, `registry.k8s.io` will be used by default; in case of kubernetes version is a CI build (kubernetes version starts with `ci/` or `ci-cross/`)\n`gcr.io/k8s-staging-ci-images` will be used as a default for control plane components and for kube-proxy, while `registry.k8s.io`\nwill be used for all the other images.",
                  "type": "string"
                },
                "kind": {
                  "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                  "type": "string"
                },
                "kubernetesVersion": {
                  "description": "kubernetesVersion is the target version of the control plane.\nNB: This value defaults to the Machine object spec.version",
                  "type": "string"
                },
                "networking": {
                  "description": "networking holds configuration for the networking topology of the cluster.\nNB: This value defaults to the Cluster object spec.clusterNetwork.",
                  "type": "object",
                  "properties": {
                    "dnsDomain": {
                      "description": "dnsDomain is the dns domain used by k8s services. Defaults to \"cluster.local\".",
                      "type": "string"
                    },
                    "podSubnet": {
                      "description": "podSubnet is the subnet used by pods.\nIf unset, the API server will not allocate CIDR ranges for every node.\nDefaults to a comma-delimited string of the Cluster object's spec.clusterNetwork.services.cidrBlocks if that is set",
                      "type": "string"
                    },
                    "serviceSubnet": {
                      "description": "serviceSubnet is the subnet used by k8s services.\nDefaults to a comma-delimited string of the Cluster object's spec.clusterNetwork.pods.cidrBlocks, or\nto \"10.96.0.0/12\" if that's unset.",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                },
                "scheduler": {
                  "description": "scheduler contains extra settings for the scheduler control plane component",
                  "type": "object",
                  "properties": {
                    "extraArgs": {
                      "description": "extraArgs is an extra set of flags to pass to the control plane component.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "extraVolumes": {
                      "description": "extraVolumes is an extra set of host volumes, mounted to the control plane component.",
                      "type": "array",
                      "items": {
                        "description": "HostPathMount contains elements describing volumes that are mounted from the\nhost.",
                        "type": "object",
                        "required": [
                          "hostPath",
                          "mountPath",
                          "name"
                        ],
                        "properties": {
                          "hostPath": {
                            "description": "hostPath is the path in the host that will be mounted inside\nthe pod.",
                            "type": "string"
                          },
                          "mountPath": {
                            "description": "mountPath is the path inside the pod where hostPath will be mounted.",
                            "type": "string"
                          },
                          "name": {
                            "description": "name of the volume inside the pod template.",
                            "type": "string"
                          },
                          "pathType": {
                            "description": "pathType is the type of the HostPath.",
                            "type": "string"
                          },
                          "readOnly": {
                            "description": "readOnly controls write access to the volume",
                            "type": "boolean"
                          }
                        },
                        "additionalProperties": false
                      }
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "diskSetup": {
              "description": "diskSetup specifies options for the creation of partition tables and file systems on devices.",
              "type": "object",
              "properties": {
                "filesystems": {
                  "description": "filesystems specifies the list of file systems to setup.",
                  "type": "array",
                  "items": {
                    "description": "Filesystem defines the file systems to be created.",
                    "type": "object",
                    "required": [
                      "device",
                      "filesystem",
                      "label"
                    ],
                    "properties": {
                      "device": {
                        "description": "device specifies the device name",
                        "type": "string"
                      },
                      "extraOpts": {
                        "description": "extraOpts defined extra options to add to the command for creating the file system.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "filesystem": {
                        "description": "filesystem specifies the file system type.",
                        "type": "string"
                      },
                      "label": {
                        "description": "label specifies the file system label to be used. If set to None, no label is used.",
                        "type": "string"
                      },
                      "overwrite": {
                        "description": "overwrite defines whether or not to overwrite any existing filesystem.\nIf true, any pre-existing file system will be destroyed. Use with Caution.",
                        "type": "boolean"
                      },
                      "partition": {
                        "description": "partition specifies the partition to use. The valid options are: \"auto|any\", \"auto\", \"any\", \"none\", and \u003cNUM\u003e, where NUM is the actual partition number.",
                        "type": "string"
                      },
                      "replaceFS": {
                        "description": "replaceFS is a special directive, used for Microsoft Azure that instructs cloud-init to replace a file system of \u003cFS_TYPE\u003e.\nNOTE: unless you define a label, this requires the use of the 'any' partition directive.",
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "partitions": {
                  "description": "partitions specifies the list of the partitions to setup.",
                  "type": "array",
                  "items": {
                    "description": "Partition defines how to create and layout a partition.",
                    "type": "object",
                    "required": [
                      "device",
                      "layout"
                    ],
                    "properties": {
                      "device": {
                        "description": "device is the name of the device.",
                        "type": "string"
                      },
                      "layout": {
                        "description": "layout specifies the device layout.\nIf it is true, a single partition will be created for the entire device.\nWhen layout is false, it means don't partition or ignore existing partitioning.",
                        "type": "boolean"
                      },
                      "overwrite": {
                        "description": "overwrite describes whether to skip checks and create the partition if a partition or filesystem is found on the device.\nUse with caution. Default is 'false'.",
                        "type": "boolean"
                      },
                      "tableType": {
                        "description": "tableType specifies the tupe of partition table. The following are supported:\n'mbr': default and setups a MS-DOS partition table\n'gpt': setups a GPT partition table",
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  }
                }
              },
              "additionalProperties": false
            },
            "files": {
              "description": "files specifies extra files to be passed to user_data upon creation.",
              "type": "array",
              "items": {
                "description": "File defines the input for generating write_files in cloud-init.",
                "type": "object",
                "required": [
                  "path"
                ],
                "properties": {
                  "content": {
                    "description": "content is the actual content of the file.",
                    "type": "string"
                  },
                  "contentFrom": {
                    "description": "contentFrom is a referenced source of content to populate the file.",
                    "type": "object",
                    "required": [
                      "secret"
                    ],
                    "properties": {
                      "secret": {
                        "description": "secret represents a secret that should populate this file.",
                        "type": "object",
                        "required": [
                          "key",
                          "name"
                        ],
                        "properties": {
                          "key": {
                            "description": "key is the key in the secret's data map for this value.",
                            "type": "string"
                          },
                          "name": {
                            "description": "name of the secret in the KubeadmBootstrapConfig's namespace to use.",
                            "type": "string"
                          }
                        },
                        "additionalProperties": false
                      }
                    },
                    "additionalProperties": false
                  },
                  "encoding": {
                    "description": "encoding specifies the encoding of the file contents.",
                    "type": "string",
                    "enum": [
                      "base64",
                      "gzip",
                      "gzip+base64"
                    ]
                  },
                  "owner": {
                    "description": "owner specifies the ownership of the file, e.g. \"root:root\".",
                    "type": "string"
                  },
                  "path": {
                    "description": "path specifies the full path on disk where to store the file.",
                    "type": "string"
                  },
                  "permissions": {
                    "description": "permissions specifies the permissions to assign to the file, e.g. \"0640\".",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "format": {
              "description": "format specifies the output format of the bootstrap data",
              "type": "string",
              "enum": [
                "cloud-config"
              ]
            },
            "initConfiguration": {
              "description": "initConfiguration along with ClusterConfiguration are the configurations necessary for the init command",
              "type": "object",
              "properties": {
                "apiVersion": {
                  "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                  "type": "string"
                },
                "bootstrapTokens": {
                  "description": "bootstrapTokens is respected at `kubeadm init` time and describes a set of Bootstrap Tokens to create.\nThis information IS NOT uploaded to the kubeadm cluster configmap, partly because of its sensitive nature",
                  "type": "array",
                  "items": {
                    "description": "BootstrapToken describes one bootstrap token, stored as a Secret in the cluster.",
                    "type": "object",
                    "required": [
                      "token"
                    ],
                    "properties": {
                      "description": {
                        "description": "description sets a human-friendly message why this token exists and what it's used\nfor, so other administrators can know its purpose.",
                        "type": "string"
                      },
                      "expires": {
                        "description": "expires specifies the timestamp when this token expires. Defaults to being set\ndynamically at runtime based on the TTL. Expires and TTL are mutually exclusive.",
                        "type": "string",
                        "format": "date-time"
                      },
                      "groups": {
                        "description": "groups specifies the extra groups that this token will authenticate as when/if\nused for authentication",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      },
                      "token": {
                        "description": "token is used for establishing bidirectional trust between nodes and control-planes.\nUsed for joining nodes in the cluster.",
                        "type": "string"
                      },
                      "ttl": {
                        "description": "ttl defines the time to live for this token. Defaults to 24h.\nExpires and TTL are mutually exclusive.",
                        "type": "string"
                      },
                      "usages": {
                        "description": "usages describes the ways in which this token can be used. Can by default be used\nfor establishing bidirectional trust, but that can be changed here.",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "kind": {
                  "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                  "type": "string"
                },
                "localAPIEndpoint": {
                  "description": "localAPIEndpoint represents the endpoint of the API server instance that's deployed on this control plane node\nIn HA setups, this differs from ClusterConfiguration.ControlPlaneEndpoint in the sense that ControlPlaneEndpoint\nis the global endpoint for the cluster, which then loadbalances the requests to each individual API server. This\nconfiguration object lets you customize what IP/DNS name and port the local API server advertises it's accessible\non. By default, kubeadm tries to auto-detect the IP of the default interface and use that, but in case that process\nfails you may set the desired value here.",
                  "type": "object",
                  "properties": {
                    "advertiseAddress": {
                      "description": "advertiseAddress sets the IP address for the API server to advertise.",
                      "type": "string"
                    },
                    "bindPort": {
                      "description": "bindPort sets the secure port for the API Server to bind to.\nDefaults to 6443.",
                      "type": "integer",
                      "format": "int32"
                    }
                  },
                  "additionalProperties": false
                },
                "nodeRegistration": {
                  "description": "nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.\nWhen used in the context of control plane nodes, NodeRegistration should remain consistent\nacross both InitConfiguration and JoinConfiguration",
                  "type": "object",
                  "properties": {
                    "criSocket": {
                      "description": "criSocket is used to retrieve container runtime info. This information will be annotated to the Node API object, for later re-use",
                      "type": "string"
                    },
                    "ignorePreflightErrors": {
                      "description": "ignorePreflightErrors provides a slice of pre-flight errors to be ignored when the current node is registered.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "kubeletExtraArgs": {
                      "description": "kubeletExtraArgs passes through extra arguments to the kubelet. The arguments here are passed to the kubelet command line via the environment file\nkubeadm writes at runtime for the kubelet to source. This overrides the generic base-level configuration in the kubelet-config-1.X ConfigMap\nFlags have higher priority when parsing. These values are local and specific to the node kubeadm is executing on.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "name": {
                      "description": "name is the `.Metadata.Name` field of the Node API object that will be created in this `kubeadm init` or `kubeadm join` operation.\nThis field is also used in the CommonName field of the kubelet's client certificate to the API server.\nDefaults to the hostname of the node if not provided.",
                      "type": "string"
                    },
                    "taints": {
                      "description": "taints specifies the taints the Node API object should be registered with. If this field is unset, i.e. nil, in the `kubeadm init` process\nit will be defaulted to []v1.Taint{'node-role.kubernetes.io/master=\"\"'}. If you don't want to taint your control-plane node, set this field to an\nempty slice, i.e. `taints: {}` in the YAML file. This field is solely used for Node registration.",
                      "type": "array",
                      "items": {
                        "description": "The node this Taint is attached to has the \"effect\" on\nany pod that does not tolerate the Taint.",
                        "type": "object",
                        "required": [
                          "effect",
                          "key"
                        ],
                        "properties": {
                          "effect": {
                            "description": "Required. The effect of the taint on pods\nthat do not tolerate the taint.\nValid effects are NoSchedule, PreferNoSchedule and NoExecute.",
                            "type": "string"
                          },
                          "key": {
                            "description": "Required. The taint key to be applied to a node.",
                            "type": "string"
                          },
                          "timeAdded": {
                            "description": "TimeAdded represents the time at which the taint was added.\nIt is only written for NoExecute taints.",
                            "type": "string",
                            "format": "date-time"
                          },
                          "value": {
                            "description": "The taint value corresponding to the taint key.",
                            "type": "string"
                          }
                        },
                        "additionalProperties": false
                      }
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "joinConfiguration": {
              "description": "joinConfiguration is the kubeadm configuration for the join command",
              "type": "object",
              "properties": {
                "apiVersion": {
                  "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
                  "type": "string"
                },
                "caCertPath": {
                  "description": "caCertPath is the path to the SSL certificate authority used to\nsecure comunications between node and control-plane.\nDefaults to \"/etc/kubernetes/pki/ca.crt\".",
                  "type": "string"
                },
                "controlPlane": {
                  "description": "controlPlane defines the additional control plane instance to be deployed on the joining node.\nIf nil, no additional control plane instance will be deployed.",
                  "type": "object",
                  "properties": {
                    "localAPIEndpoint": {
                      "description": "localAPIEndpoint represents the endpoint of the API server instance to be deployed on this node.",
                      "type": "object",
                      "properties": {
                        "advertiseAddress": {
                          "description": "advertiseAddress sets the IP address for the API server to advertise.",
                          "type": "string"
                        },
                        "bindPort": {
                          "description": "bindPort sets the secure port for the API Server to bind to.\nDefaults to 6443.",
                          "type": "integer",
                          "format": "int32"
                        }
                      },
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                },
                "discovery": {
                  "description": "discovery specifies the options for the kubelet to use during the TLS Bootstrap process",
                  "type": "object",
                  "properties": {
                    "bootstrapToken": {
                      "description": "bootstrapToken is used to set the options for bootstrap token based discovery\nBootstrapToken and File are mutually exclusive",
                      "type": "object",
                      "required": [
                        "token"
                      ],
                      "properties": {
                        "apiServerEndpoint": {
                          "description": "apiServerEndpoint is an IP or domain name to the API server from which info will be fetched.",
                          "type": "string"
                        },
                        "caCertHashes": {
                          "description": "caCertHashes specifies a set of public key pins to verify\nwhen token-based discovery is used. The root CA found during discovery\nmust match one of these values. Specifying an empty set disables root CA\npinning, which can be unsafe. Each hash is specified as \"\u003ctype\u003e:\u003cvalue\u003e\",\nwhere the only currently supported type is \"sha256\". This is a hex-encoded\nSHA-256 hash of the Subject Public Key Info (SPKI) object in DER-encoded\nASN.1. These hashes can be calculated using, for example, OpenSSL:\nopenssl x509 -pubkey -in ca.crt openssl rsa -pubin -outform der 2\u003e\u0026/dev/null | openssl dgst -sha256 -hex",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "token": {
                          "description": "token is a token used to validate cluster information\nfetched from the control-plane.",
                          "type": "string"
                        },
                        "unsafeSkipCAVerification": {
                          "description": "unsafeSkipCAVerification allows token-based discovery\nwithout CA verification via CACertHashes. This can weaken\nthe security of kubeadm since other nodes can impersonate the control-plane.",
                          "type": "boolean"
                        }
                      },
                      "additionalProperties": false
                    },
                    "file": {
                      "description": "file is used to specify a file or URL to a kubeconfig file from which to load cluster information\nBootstrapToken and File are mutually exclusive",
                      "type": "object",
                      "required": [
                        "kubeConfigPath"
                      ],
                      "properties": {
                        "kubeConfigPath": {
                          "description": "kubeConfigPath is used to specify the actual file path or URL to the kubeconfig file from which to load cluster information",
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    },
                    "timeout": {
                      "description": "timeout modifies the discovery timeout",
                      "type": "string"
                    },
                    "tlsBootstrapToken": {
                      "description": "tlsBootstrapToken is a token used for TLS bootstrapping.\nIf .BootstrapToken is set, this field is defaulted to .BootstrapToken.Token, but can be overridden.\nIf .File is set, this field **must be set** in case the KubeConfigFile does not contain any other authentication information",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                },
                "kind": {
                  "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                  "type": "string"
                },
                "nodeRegistration": {
                  "description": "nodeRegistration holds fields that relate to registering the new control-plane node to the cluster.\nWhen used in the context of control plane nodes, NodeRegistration should remain consistent\nacross both InitConfiguration and JoinConfiguration",
                  "type": "object",
                  "properties": {
                    "criSocket": {
                      "description": "criSocket is used to retrieve container runtime info. This information will be annotated to the Node API object, for later re-use",
                      "type": "string"
                    },
                    "ignorePreflightErrors": {
                      "description": "ignorePreflightErrors provides a slice of pre-flight errors to be ignored when the current node is registered.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "kubeletExtraArgs": {
                      "description": "kubeletExtraArgs passes through extra arguments to the kubelet. The arguments here are passed to the kubelet command line via the environment file\nkubeadm writes at runtime for the kubelet to source. This overrides the generic base-level configuration in the kubelet-config-1.X ConfigMap\nFlags have higher priority when parsing. These values are local and specific to the node kubeadm is executing on.",
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "name": {
                      "description": "name is the `.Metadata.Name` field of the Node API object that will be created in this `kubeadm init` or `kubeadm join` operation.\nThis field is also used in the CommonName field of the kubelet's client certificate to the API server.\nDefaults to the hostname of the node if not provided.",
                      "type": "string"
                    },
                    "taints": {
                      "description": "taints specifies the taints the Node API object should be registered with. If this field is unset, i.e. nil, in the `kubeadm init` process\nit will be defaulted to []v1.Taint{'node-role.kubernetes.io/master=\"\"'}. If you don't want to taint your control-plane node, set this field to an\nempty slice, i.e. `taints: {}` in the YAML file. This field is solely used for Node registration.",
                      "type": "array",
                      "items": {
                        "description": "The node this Taint is attached to has the \"effect\" on\nany pod that does not tolerate the Taint.",
                        "type": "object",
                        "required": [
                          "effect",
                          "key"
                        ],
                        "properties": {
                          "effect": {
                            "description": "Required. The effect of the taint on pods\nthat do not tolerate the taint.\nValid effects are NoSchedule, PreferNoSchedule and NoExecute.",
                            "type": "string"
                          },
                          "key": {
                            "description": "Required. The taint key to be applied to a node.",
                            "type": "string"
                          },
                          "timeAdded": {
                            "description": "TimeAdded represents the time at which the taint was added.\nIt is only written for NoExecute taints.",
                            "type": "string",
                            "format": "date-time"
                          },
                          "value": {
                            "description": "The taint value corresponding to the taint key.",
                            "type": "string"
                          }
                        },
                        "additionalProperties": false
                      }
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "mounts": {
              "description": "mounts specifies a list of mount points to be setup.",
              "type": "array",
              "items": {
                "description": "MountPoints defines input for generated mounts in cloud-init.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "ntp": {
              "description": "ntp specifies NTP configuration",
              "type": "object",
              "properties": {
                "enabled": {
                  "description": "enabled specifies whether NTP should be enabled",
                  "type": "boolean"
                },
                "servers": {
                  "description": "servers specifies which NTP servers to use",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "additionalProperties": false
            },
            "postKubeadmCommands": {
              "description": "postKubeadmCommands specifies extra commands to run after kubeadm runs",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "preKubeadmCommands": {
              "description": "preKubeadmCommands specifies extra commands to run before kubeadm runs",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "useExperimentalRetryJoin": {
              "description": "useExperimentalRetryJoin replaces a basic kubeadm command with a shell\nscript with retries for joins.\n\nThis is meant to be an experimental temporary workaround on some environments\nwhere joins fail due to timing (and other issues). The long term goal is to add retries to\nkubeadm proper and use that functionality.\n\nThis will add about 40KB to userdata\n\nFor more information, refer to https://github.com/kubernetes-sigs/cluster-api/pull/2763#discussion_r397306055.",
              "type": "boolean"
            },
            "users": {
              "description": "users specifies extra users to add",
              "type": "array",
              "items": {
                "description": "User defines the input for a generated user in cloud-init.",
                "type": "object",
                "required": [
                  "name"
                ],
                "properties": {
                  "gecos": {
                    "description": "gecos specifies the gecos to use for the user",
                    "type": "string"
                  },
                  "groups": {
                    "description": "groups specifies the additional groups for the user",
                    "type": "string"
                  },
                  "homeDir": {
                    "description": "homeDir specifies the home directory to use for the user",
                    "type": "string"
                  },
                  "inactive": {
                    "description": "inactive specifies whether to mark the user as inactive",
                    "type": "boolean"
                  },
                  "lockPassword": {
                    "description": "lockPassword specifies if password login should be disabled",
                    "type": "boolean"
                  },
                  "name": {
                    "description": "name specifies the user name",
                    "type": "string"
                  },
                  "passwd": {
                    "description": "passwd specifies a hashed password for the user",
                    "type": "string"
                  },
                  "primaryGroup": {
                    "description": "primaryGroup specifies the primary group for the user",
                    "type": "string"
                  },
                  "shell": {
                    "description": "shell specifies the user's shell",
                    "type": "string"
                  },
                  "sshAuthorizedKeys": {
                    "description": "sshAuthorizedKeys specifies a list of ssh authorized keys for the user",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "sudo": {
                    "description": "sudo specifies a sudo role for the user",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "verbosity": {
              "description": "verbosity is the number for the kubeadm log level verbosity.\nIt overrides the `--v` flag in kubeadm commands.",
              "type": "integer",
              "format": "int32"
            }
          },
          "additionalProperties": false
        },
        "machineTemplate": {
          "description": "machineTemplate contains information about how machines\nshould be shaped when creating or updating a control plane.",
          "type": "object",
          "required": [
            "infrastructureRef"
          ],
          "properties": {
            "infrastructureRef": {
              "description": "infrastructureRef is a required reference to a custom resource\noffered by an infrastructure provider.",
              "type": "object",
              "properties": {
                "apiVersion": {
                  "description": "API version of the referent.",
                  "type": "string"
                },
                "fieldPath": {
                  "description": "If referring to a piece of an object instead of an entire object, this string\nshould contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].\nFor example, if the object reference is to a container within a pod, this would take on a value like:\n\"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered\nthe event) or if no container name is specified \"spec.containers[2]\" (container with\nindex 2 in this pod). This syntax is chosen only to have some well-defined way of\nreferencing a part of an object.",
                  "type": "string"
                },
                "kind": {
                  "description": "Kind of the referent.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                  "type": "string"
                },
                "namespace": {
                  "description": "Namespace of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                  "type": "string"
                },
                "resourceVersion": {
                  "description": "Specific resourceVersion to which this reference is made, if any.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency",
                  "type": "string"
                },
                "uid": {
                  "description": "UID of the referent.\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids",
                  "type": "string"
                }
              },
              "additionalProperties": false,
              "x-kubernetes-map-type": "atomic"
            },
            "metadata": {
              "description": "metadata is the standard object's metadata.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata",
              "type": "object",
              "properties": {
                "annotations": {
                  "description": "annotations is an unstructured key value map stored with a resource that may be\nset by external tools to store and retrieve arbitrary metadata. They are not\nqueryable and should be preserved when modifying objects.\nMore info: http://kubernetes.io/docs/user-guide/annotations",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "description": "labels is a map of string keys and values that can be used to organize and categorize\n(scope and select) objects. May match selectors of replication controllers\nand services.\nMore info: http://kubernetes.io/docs/user-guide/labels",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              },
              "additionalProperties": false
            },
            "nodeDrainTimeout": {
              "description": "nodeDrainTimeout is the total amount of time that the controller will spend on draining a controlplane node\nThe default value is 0, meaning that the node can be drained without any time limitations.\nNOTE: NodeDrainTimeout is different from `kubectl drain --timeout`",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "replicas": {
          "description": "replicas is the number of desired machines. Defaults to 1. When stacked etcd is used only\nodd numbers are permitted, as per [etcd best practice](https://etcd.io/docs/v3.3.12/faq/#why-an-odd-number-of-cluster-members).\nThis is a pointer to distinguish between explicit zero and not specified.",
          "type": "integer",
          "format": "int32"
        },
        "rolloutAfter": {
          "description": "rolloutAfter is a field to indicate a rollout should be performed\nafter the specified time even if no changes have been made to the\nKubeadmControlPlane.",
          "type": "string",
          "format": "date-time"
        },
        "rolloutStrategy": {
          "description": "rolloutStrategy is the RolloutStrategy to use to replace control plane machines with\nnew ones.",
          "type": "object",
          "default": {
            "rollingUpdate": {
              "maxSurge": 1
            },
            "type": "RollingUpdate"
          },
          "properties": {
            "rollingUpdate": {
              "description": "rollingUpdate is the rolling update config params. Present only if\nRolloutStrategyType = RollingUpdate.",
              "type": "object",
              "properties": {
                "maxSurge": {
                  "description": "maxSurge is the maximum number of control planes that can be scheduled above or under the\ndesired number of control planes.\nValue can be an absolute number 1 or 0.\nDefaults to 1.\nExample: when this is set to 1, the control plane can be scaled\nup immediately when the rolling update starts.",
                  "anyOf": [
                    {
                      "type": "integer"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "x-kubernetes-int-or-string": true
                }
              },
              "additionalProperties": false
            },
            "type": {
              "description": "type of rollout. Currently the only supported strategy is\n\"RollingUpdate\".\nDefault is RollingUpdate.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "version": {
          "description": "version defines the desired Kubernetes version.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "status": {
      "description": "status is the observed state of KubeadmControlPlane.",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "conditions defines current service state of the KubeadmControlPlane.",
          "type": "array",
          "items": {
            "description": "Condition defines an observation of a Cluster API resource operational state.",
            "type": "object",
            "required": [
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed. If that is not known, then using the time when\nthe API field changed is acceptable.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition.\nThis field may be empty.",
                "type": "string"
              },
              "reason": {
                "description": "reason is the reason for the condition's last transition in CamelCase.\nThe specific API may choose whether or not this field is considered a guaranteed API.\nThis field may not be empty.",
                "type": "string"
              },
              "severity": {
                "description": "severity provides an explicit classification of Reason code, so the users or machines can immediately\nunderstand the current situation and act accordingly.\nThe Severity field MUST be set only when Status=False.",
                "type": "string"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "type": "string"
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions\ncan be useful (see .node.status.conditions), the ability to deconflict is important.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "failureMessage": {
          "description": "failureMessage indicates that there is a terminal problem reconciling the\nstate, and will be set to a descriptive error message.",
          "type": "string"
        },
        "failureReason": {
          "description": "failureReason indicates that there is a terminal problem reconciling the\nstate, and will be set to a token value suitable for\nprogrammatic interpretation.",
          "type": "string"
        },
        "initialized": {
          "description": "initialized denotes whether or not the control plane has the\nuploaded kubeadm-config configmap.",
          "type": "boolean"
        },
        "observedGeneration": {
          "description": "observedGeneration is the latest generation observed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "ready": {
          "description": "ready denotes that the KubeadmControlPlane API Server is ready to\nreceive requests.",
          "type": "boolean"
        },
        "readyReplicas": {
          "description": "readyReplicas is the total number of fully running and ready control plane machines.",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "replicas is the total number of non-terminated machines targeted by this control plane\n(their labels match the selector).",
          "type": "integer",
          "format": "int32"
        },
        "selector": {
          "description": "selector is the label selector in string format to avoid introspection\nby clients, and is used to provide the CRD-based integration for the\nscale subresource and additional integrations for things like kubectl\ndescribe.. The string will be in the same format as the query-param syntax.\nMore info about label selectors: http://kubernetes.io/docs/user-guide/labels#label-selectors",
          "type": "string"
        },
        "unavailableReplicas": {
          "description": "unavailableReplicas is the total number of unavailable machines targeted by this control plane.\nThis is the total number of machines that are still required for\nthe deployment to have 100% available capacity. They may either\nbe machines that are running but not yet ready or machines\nthat still have not been created.",
          "type": "integer",
          "format": "int32"
        },
        "updatedReplicas": {
          "description": "updatedReplicas is the total number of non-terminated machines targeted by this control plane\nthat have the desired template spec.",
          "type": "integer",
          "format": "int32"
        },
        "version": {
          "description": "version represents the minimum Kubernetes version for the control plane machines\nin the cluster.",
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}
