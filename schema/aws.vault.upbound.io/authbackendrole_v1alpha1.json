{
  "description": "AuthBackendRole is the Schema for the AuthBackendRoles API. Manages AWS auth backend roles in Vault.",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "AuthBackendRoleSpec defines the desired state of AuthBackendRole",
      "type": "object",
      "required": [
        "forProvider"
      ],
      "properties": {
        "deletionPolicy": {
          "description": "DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either \"Delete\" or \"Orphan\" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223",
          "type": "string",
          "default": "Delete",
          "enum": [
            "Orphan",
            "Delete"
          ]
        },
        "forProvider": {
          "type": "object",
          "properties": {
            "allowInstanceMigration": {
              "description": "If set to true, allows migration of\nthe underlying instance where the client resides.\nWhen true, allows migration of the underlying instance where the client resides. Use with caution.",
              "type": "boolean"
            },
            "authType": {
              "description": "The auth type permitted for this role. Valid choices\nare ec2 and iam. Defaults to iam.\nThe auth type permitted for this role.",
              "type": "string"
            },
            "backend": {
              "description": "Path to the mounted aws auth backend.\nUnique name of the auth backend to configure.",
              "type": "string"
            },
            "backendRef": {
              "description": "Reference to a Backend in auth to populate backend.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "backendSelector": {
              "description": "Selector for a Backend in auth to populate backend.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "boundAccountIds": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances with this account ID in their identity document will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundAmiIds": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances using this AMI ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundEc2InstanceIds": {
              "description": "Only EC2 instances that match this instance ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamInstanceProfileArns": {
              "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in *. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances associated with an IAM instance profile ARN that matches this value will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamPrincipalArns": {
              "description": "If set, defines the IAM principal that\nmust be authenticated when auth_type is set to iam. Wildcards are\nsupported at the end of the ARN.\nThe IAM principal that must be authenticated using the iam auth method.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamRoleArns": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances that match this IAM role ARN will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundRegions": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. auth_type must be set\nto ec2 or inferred_entity_type must be set to ec2_instance to use this\nconstraint.\nOnly EC2 instances in this region will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundSubnetIds": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. auth_type\nmust be set to ec2 or inferred_entity_type must be set to ec2_instance\nto use this constraint.\nOnly EC2 instances associated with this subnet ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundVpcIds": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. auth_type must be set to\nec2 or inferred_entity_type must be set to ec2_instance to use this\nconstraint.\nOnly EC2 instances associated with this VPC ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "disallowReauthentication": {
              "description": "IF set to true, only allows a\nsingle token to be granted per instance ID. This can only be set when\nauth_type is set to ec2.\nWhen true, only allows a single token to be granted per instance ID.",
              "type": "boolean"
            },
            "inferredAwsRegion": {
              "description": "When inferred_entity_type is set, this\nis the region to search for the inferred entities. Required if\ninferred_entity_type is set. This only applies when auth_type is set to\niam.\nThe region to search for the inferred entities in.",
              "type": "string"
            },
            "inferredEntityType": {
              "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is ec2_instance, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when auth_type is set to iam.\nThe type of inferencing Vault should do.",
              "type": "string"
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "resolveAwsUniqueIds": {
              "description": "Only valid when\nauth_type is iam. If set to true, the bound_iam_principal_arns are\nresolved to AWS Unique\nIDs\nfor the bound principal ARN. This field is ignored when a\nbound_iam_principal_arn ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to true.\nOnce set to true, this cannot be changed to false without recreating the role.\nWhether or not Vault should resolve the bound_iam_principal_arn to an AWS Unique ID. When true, deleting a principal and recreating it with the same name won't automatically grant the new principal the same roles in Vault that the old principal had.",
              "type": "boolean"
            },
            "role": {
              "description": "The name of the role.\nName of the role.",
              "type": "string"
            },
            "roleTag": {
              "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. auth_type\nmust be set to ec2 or inferred_entity_type must be set to ec2_instance\nto use this constraint.\nThe key of the tag on EC2 instance to use for role tags.",
              "type": "string"
            },
            "tokenBoundCidrs": {
              "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\nSpecifies the blocks of IP addresses which are allowed to use the generated token",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "tokenExplicitMaxTtl": {
              "description": "If set, will encode an\nexplicit max TTL\nonto the token in number of seconds. This is a hard cap even if token_ttl and\ntoken_max_ttl would otherwise allow a renewal.\nGenerated Token's Explicit Maximum TTL in seconds",
              "type": "number"
            },
            "tokenMaxTtl": {
              "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\nThe maximum lifetime of the generated token",
              "type": "number"
            },
            "tokenNoDefaultPolicy": {
              "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\nIf true, the 'default' policy will not automatically be added to generated tokens",
              "type": "boolean"
            },
            "tokenNumUses": {
              "description": "The maximum number\nof times a generated token may be used (within its lifetime); 0 means unlimited.\nThe maximum number of times a token may be used, a value of zero means unlimited",
              "type": "number"
            },
            "tokenPeriod": {
              "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\nGenerated Token's Period",
              "type": "number"
            },
            "tokenPolicies": {
              "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\nGenerated Token's Policies",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "tokenTtl": {
              "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\nThe initial ttl of the token to generate in seconds",
              "type": "number"
            },
            "tokenType": {
              "description": "The type of token that should be generated. Can be service,\nbatch, or default to use the mount's tuned default (which unless changed will be\nservice tokens). For token store roles, there are two additional possibilities:\ndefault-service and default-batch which specify the type to return unless the client\nrequests a different type at generation time.\nThe type of token to generate, service or batch",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "initProvider": {
          "description": "THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.",
          "type": "object",
          "properties": {
            "allowInstanceMigration": {
              "description": "If set to true, allows migration of\nthe underlying instance where the client resides.\nWhen true, allows migration of the underlying instance where the client resides. Use with caution.",
              "type": "boolean"
            },
            "authType": {
              "description": "The auth type permitted for this role. Valid choices\nare ec2 and iam. Defaults to iam.\nThe auth type permitted for this role.",
              "type": "string"
            },
            "backend": {
              "description": "Path to the mounted aws auth backend.\nUnique name of the auth backend to configure.",
              "type": "string"
            },
            "backendRef": {
              "description": "Reference to a Backend in auth to populate backend.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "backendSelector": {
              "description": "Selector for a Backend in auth to populate backend.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "boundAccountIds": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances with this account ID in their identity document will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundAmiIds": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances using this AMI ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundEc2InstanceIds": {
              "description": "Only EC2 instances that match this instance ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamInstanceProfileArns": {
              "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in *. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances associated with an IAM instance profile ARN that matches this value will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamPrincipalArns": {
              "description": "If set, defines the IAM principal that\nmust be authenticated when auth_type is set to iam. Wildcards are\nsupported at the end of the ARN.\nThe IAM principal that must be authenticated using the iam auth method.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamRoleArns": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances that match this IAM role ARN will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundRegions": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. auth_type must be set\nto ec2 or inferred_entity_type must be set to ec2_instance to use this\nconstraint.\nOnly EC2 instances in this region will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundSubnetIds": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. auth_type\nmust be set to ec2 or inferred_entity_type must be set to ec2_instance\nto use this constraint.\nOnly EC2 instances associated with this subnet ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundVpcIds": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. auth_type must be set to\nec2 or inferred_entity_type must be set to ec2_instance to use this\nconstraint.\nOnly EC2 instances associated with this VPC ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "disallowReauthentication": {
              "description": "IF set to true, only allows a\nsingle token to be granted per instance ID. This can only be set when\nauth_type is set to ec2.\nWhen true, only allows a single token to be granted per instance ID.",
              "type": "boolean"
            },
            "inferredAwsRegion": {
              "description": "When inferred_entity_type is set, this\nis the region to search for the inferred entities. Required if\ninferred_entity_type is set. This only applies when auth_type is set to\niam.\nThe region to search for the inferred entities in.",
              "type": "string"
            },
            "inferredEntityType": {
              "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is ec2_instance, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when auth_type is set to iam.\nThe type of inferencing Vault should do.",
              "type": "string"
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "resolveAwsUniqueIds": {
              "description": "Only valid when\nauth_type is iam. If set to true, the bound_iam_principal_arns are\nresolved to AWS Unique\nIDs\nfor the bound principal ARN. This field is ignored when a\nbound_iam_principal_arn ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to true.\nOnce set to true, this cannot be changed to false without recreating the role.\nWhether or not Vault should resolve the bound_iam_principal_arn to an AWS Unique ID. When true, deleting a principal and recreating it with the same name won't automatically grant the new principal the same roles in Vault that the old principal had.",
              "type": "boolean"
            },
            "role": {
              "description": "The name of the role.\nName of the role.",
              "type": "string"
            },
            "roleTag": {
              "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. auth_type\nmust be set to ec2 or inferred_entity_type must be set to ec2_instance\nto use this constraint.\nThe key of the tag on EC2 instance to use for role tags.",
              "type": "string"
            },
            "tokenBoundCidrs": {
              "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\nSpecifies the blocks of IP addresses which are allowed to use the generated token",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "tokenExplicitMaxTtl": {
              "description": "If set, will encode an\nexplicit max TTL\nonto the token in number of seconds. This is a hard cap even if token_ttl and\ntoken_max_ttl would otherwise allow a renewal.\nGenerated Token's Explicit Maximum TTL in seconds",
              "type": "number"
            },
            "tokenMaxTtl": {
              "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\nThe maximum lifetime of the generated token",
              "type": "number"
            },
            "tokenNoDefaultPolicy": {
              "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\nIf true, the 'default' policy will not automatically be added to generated tokens",
              "type": "boolean"
            },
            "tokenNumUses": {
              "description": "The maximum number\nof times a generated token may be used (within its lifetime); 0 means unlimited.\nThe maximum number of times a token may be used, a value of zero means unlimited",
              "type": "number"
            },
            "tokenPeriod": {
              "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\nGenerated Token's Period",
              "type": "number"
            },
            "tokenPolicies": {
              "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\nGenerated Token's Policies",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "tokenTtl": {
              "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\nThe initial ttl of the token to generate in seconds",
              "type": "number"
            },
            "tokenType": {
              "description": "The type of token that should be generated. Can be service,\nbatch, or default to use the mount's tuned default (which unless changed will be\nservice tokens). For token store roles, there are two additional possibilities:\ndefault-service and default-batch which specify the type to return unless the client\nrequests a different type at generation time.\nThe type of token to generate, service or batch",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "managementPolicies": {
          "description": "THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md",
          "type": "array",
          "default": [
            "*"
          ],
          "items": {
            "description": "A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.",
            "type": "string",
            "enum": [
              "Observe",
              "Create",
              "Update",
              "Delete",
              "LateInitialize",
              "*"
            ]
          }
        },
        "providerConfigRef": {
          "description": "ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.",
          "type": "object",
          "default": {
            "name": "default"
          },
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "Name of the referenced object.",
              "type": "string"
            },
            "policy": {
              "description": "Policies for referencing.",
              "type": "object",
              "properties": {
                "resolution": {
                  "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                  "type": "string",
                  "default": "Required",
                  "enum": [
                    "Required",
                    "Optional"
                  ]
                },
                "resolve": {
                  "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                  "type": "string",
                  "enum": [
                    "Always",
                    "IfNotPresent"
                  ]
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "writeConnectionSecretToRef": {
          "description": "WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.",
          "type": "object",
          "required": [
            "name",
            "namespace"
          ],
          "properties": {
            "name": {
              "description": "Name of the secret.",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace of the secret.",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "x-kubernetes-validations": [
        {
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.role) || (has(self.initProvider) \u0026\u0026 has(self.initProvider.role))",
          "message": "spec.forProvider.role is a required parameter"
        }
      ]
    },
    "status": {
      "description": "AuthBackendRoleStatus defines the observed state of AuthBackendRole.",
      "type": "object",
      "properties": {
        "atProvider": {
          "type": "object",
          "properties": {
            "allowInstanceMigration": {
              "description": "If set to true, allows migration of\nthe underlying instance where the client resides.\nWhen true, allows migration of the underlying instance where the client resides. Use with caution.",
              "type": "boolean"
            },
            "authType": {
              "description": "The auth type permitted for this role. Valid choices\nare ec2 and iam. Defaults to iam.\nThe auth type permitted for this role.",
              "type": "string"
            },
            "backend": {
              "description": "Path to the mounted aws auth backend.\nUnique name of the auth backend to configure.",
              "type": "string"
            },
            "boundAccountIds": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they should be using the\naccount ID specified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances with this account ID in their identity document will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundAmiIds": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they should be using the AMI ID\nspecified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances using this AMI ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundEc2InstanceIds": {
              "description": "Only EC2 instances that match this instance ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamInstanceProfileArns": {
              "description": "If set, defines a constraint on\nthe EC2 instances that can perform the login operation that they must be\nassociated with an IAM instance profile ARN which has a prefix that matches\nthe value specified by this field. The value is prefix-matched as though it\nwere a glob ending in *. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances associated with an IAM instance profile ARN that matches this value will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamPrincipalArns": {
              "description": "If set, defines the IAM principal that\nmust be authenticated when auth_type is set to iam. Wildcards are\nsupported at the end of the ARN.\nThe IAM principal that must be authenticated using the iam auth method.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundIamRoleArns": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they must match the IAM\nrole ARN specified by this field. auth_type must be set to ec2 or\ninferred_entity_type must be set to ec2_instance to use this constraint.\nOnly EC2 instances that match this IAM role ARN will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundRegions": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that the region in their identity\ndocument must match the one specified by this field. auth_type must be set\nto ec2 or inferred_entity_type must be set to ec2_instance to use this\nconstraint.\nOnly EC2 instances in this region will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundSubnetIds": {
              "description": "If set, defines a constraint on the EC2\ninstances that can perform the login operation that they be associated with\nthe subnet ID that matches the value specified by this field. auth_type\nmust be set to ec2 or inferred_entity_type must be set to ec2_instance\nto use this constraint.\nOnly EC2 instances associated with this subnet ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "boundVpcIds": {
              "description": "If set, defines a constraint on the EC2 instances\nthat can perform the login operation that they be associated with the VPC ID\nthat matches the value specified by this field. auth_type must be set to\nec2 or inferred_entity_type must be set to ec2_instance to use this\nconstraint.\nOnly EC2 instances associated with this VPC ID will be permitted to log in.",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "disallowReauthentication": {
              "description": "IF set to true, only allows a\nsingle token to be granted per instance ID. This can only be set when\nauth_type is set to ec2.\nWhen true, only allows a single token to be granted per instance ID.",
              "type": "boolean"
            },
            "id": {
              "type": "string"
            },
            "inferredAwsRegion": {
              "description": "When inferred_entity_type is set, this\nis the region to search for the inferred entities. Required if\ninferred_entity_type is set. This only applies when auth_type is set to\niam.\nThe region to search for the inferred entities in.",
              "type": "string"
            },
            "inferredEntityType": {
              "description": "If set, instructs Vault to turn on\ninferencing. The only valid value is ec2_instance, which instructs Vault to\ninfer that the role comes from an EC2 instance in an IAM instance profile.\nThis only applies when auth_type is set to iam.\nThe type of inferencing Vault should do.",
              "type": "string"
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "resolveAwsUniqueIds": {
              "description": "Only valid when\nauth_type is iam. If set to true, the bound_iam_principal_arns are\nresolved to AWS Unique\nIDs\nfor the bound principal ARN. This field is ignored when a\nbound_iam_principal_arn ends in a wildcard. Resolving to unique IDs more\nclosely mimics the behavior of AWS services in that if an IAM user or role is\ndeleted and a new one is recreated with the same name, those new users or\nroles won't get access to roles in Vault that were permissioned to the prior\nprincipals of the same name. Defaults to true.\nOnce set to true, this cannot be changed to false without recreating the role.\nWhether or not Vault should resolve the bound_iam_principal_arn to an AWS Unique ID. When true, deleting a principal and recreating it with the same name won't automatically grant the new principal the same roles in Vault that the old principal had.",
              "type": "boolean"
            },
            "role": {
              "description": "The name of the role.\nName of the role.",
              "type": "string"
            },
            "roleId": {
              "description": "The Vault generated role ID.\nThe Vault generated role ID.",
              "type": "string"
            },
            "roleTag": {
              "description": "If set, enable role tags for this role. The value set\nfor this field should be the key of the tag on the EC2 instance. auth_type\nmust be set to ec2 or inferred_entity_type must be set to ec2_instance\nto use this constraint.\nThe key of the tag on EC2 instance to use for role tags.",
              "type": "string"
            },
            "tokenBoundCidrs": {
              "description": "List of CIDR blocks; if set, specifies blocks of IP\naddresses which can authenticate successfully, and ties the resulting token to these blocks\nas well.\nSpecifies the blocks of IP addresses which are allowed to use the generated token",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "tokenExplicitMaxTtl": {
              "description": "If set, will encode an\nexplicit max TTL\nonto the token in number of seconds. This is a hard cap even if token_ttl and\ntoken_max_ttl would otherwise allow a renewal.\nGenerated Token's Explicit Maximum TTL in seconds",
              "type": "number"
            },
            "tokenMaxTtl": {
              "description": "The maximum lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\nThe maximum lifetime of the generated token",
              "type": "number"
            },
            "tokenNoDefaultPolicy": {
              "description": "If set, the default policy will not be set on\ngenerated tokens; otherwise it will be added to the policies set in token_policies.\nIf true, the 'default' policy will not automatically be added to generated tokens",
              "type": "boolean"
            },
            "tokenNumUses": {
              "description": "The maximum number\nof times a generated token may be used (within its lifetime); 0 means unlimited.\nThe maximum number of times a token may be used, a value of zero means unlimited",
              "type": "number"
            },
            "tokenPeriod": {
              "description": "If set, indicates that the\ntoken generated using this role should never expire. The token should be renewed within the\nduration specified by this value. At each renewal, the token's TTL will be set to the\nvalue of this field. Specified in seconds.\nGenerated Token's Period",
              "type": "number"
            },
            "tokenPolicies": {
              "description": "List of policies to encode onto generated tokens. Depending\non the auth method, this list may be supplemented by user/group/other values.\nGenerated Token's Policies",
              "type": "array",
              "items": {
                "type": "string"
              },
              "x-kubernetes-list-type": "set"
            },
            "tokenTtl": {
              "description": "The incremental lifetime for generated tokens in number of seconds.\nIts current value will be referenced at renewal time.\nThe initial ttl of the token to generate in seconds",
              "type": "number"
            },
            "tokenType": {
              "description": "The type of token that should be generated. Can be service,\nbatch, or default to use the mount's tuned default (which unless changed will be\nservice tokens). For token store roles, there are two additional possibilities:\ndefault-service and default-batch which specify the type to return unless the client\nrequests a different type at generation time.\nThe type of token to generate, service or batch",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "conditions": {
          "description": "Conditions of the resource.",
          "type": "array",
          "items": {
            "description": "A Condition that may apply to a resource.",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "LastTransitionTime is the last time this condition transitioned from one\nstatus to another.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "A Message containing details about this condition's last transition from\none status to another, if any.",
                "type": "string"
              },
              "observedGeneration": {
                "description": "ObservedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "type": "integer",
                "format": "int64"
              },
              "reason": {
                "description": "A Reason for this condition's last transition from one status to another.",
                "type": "string"
              },
              "status": {
                "description": "Status of this condition; is it currently True, False, or Unknown?",
                "type": "string"
              },
              "type": {
                "description": "Type of this condition. At most one of each condition type may apply to\na resource at any point in time.",
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the latest metadata.generation\nwhich resulted in either a ready state, or stalled due to error\nit can not recover from without human intervention.",
          "type": "integer",
          "format": "int64"
        }
      },
      "additionalProperties": false
    }
  }
}
