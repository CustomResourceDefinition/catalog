{
  "description": "ManagedCluster is the Schema for the managedclusters API",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "ManagedClusterSpec defines the desired state of ManagedCluster",
      "type": "object",
      "required": [
        "clusterId",
        "syncMode"
      ],
      "properties": {
        "clusterId": {
          "description": "ClusterID, a Random (Version 4) UUID, is a unique value in time and space value representing for child cluster.\nIt is typically generated by the clusternet agent on the successful creation of a \"clusternet-agent\" Lease\nin the child cluster.\nAlso it is not allowed to change on PUT operations.",
          "type": "string",
          "pattern": "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}"
        },
        "clusterInitBaseName": {
          "description": "ClusterInitBaseName denotes the name of a Base used for initialization.\nAlso a taint \"clusters.clusternet.io/initialization:NoSchedule\" will be added during the operation and removed\nafter successful initialization.\nIf this cluster has got an annotation \"clusters.clusternet.io/skip-cluster-init\", this field will be empty.\nNormally this field is fully managed by clusternet-controller-manager and immutable.",
          "type": "string",
          "maxLength": 512,
          "x-kubernetes-validations": [
            {
              "rule": "self == oldSelf",
              "message": "clusterInitBaseName is immutable"
            }
          ]
        },
        "clusterType": {
          "description": "ClusterType denotes the type of the child cluster.",
          "type": "string"
        },
        "syncMode": {
          "description": "SyncMode decides how to sync resources from parent cluster to child cluster.",
          "type": "string",
          "enum": [
            "Push",
            "Pull",
            "Dual"
          ]
        },
        "taints": {
          "description": "Taints has the \"effect\" on any resource that does not tolerate the Taint.",
          "type": "array",
          "items": {
            "description": "The node this Taint is attached to has the \"effect\" on\nany pod that does not tolerate the Taint.",
            "type": "object",
            "required": [
              "effect",
              "key"
            ],
            "properties": {
              "effect": {
                "description": "Required. The effect of the taint on pods\nthat do not tolerate the taint.\nValid effects are NoSchedule, PreferNoSchedule and NoExecute.",
                "type": "string"
              },
              "key": {
                "description": "Required. The taint key to be applied to a node.",
                "type": "string"
              },
              "timeAdded": {
                "description": "TimeAdded represents the time at which the taint was added.\nIt is only written for NoExecute taints.",
                "type": "string",
                "format": "date-time"
              },
              "value": {
                "description": "The taint value corresponding to the taint key.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        }
      },
      "additionalProperties": false,
      "x-kubernetes-validations": [
        {
          "rule": "!has(oldSelf.clusterInitBaseName) || has(self.clusterInitBaseName)",
          "message": "clusterInitBaseName is required once set"
        }
      ]
    },
    "status": {
      "description": "ManagedClusterStatus defines the observed state of ManagedCluster",
      "type": "object",
      "properties": {
        "agentVersion": {
          "description": "agentVersion is the clusternet agent version of the sub cluster",
          "type": "string"
        },
        "allocatable": {
          "description": "Allocatable is the sum of allocatable resources for nodes in the cluster",
          "type": "object",
          "additionalProperties": {
            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "string"
              }
            ],
            "x-kubernetes-int-or-string": true
          }
        },
        "apiserverURL": {
          "description": "APIServerURL indicates the advertising url/address of managed Kubernetes cluster",
          "type": "string"
        },
        "appPusher": {
          "description": "AppPusher indicates whether to allow parent cluster deploying applications in Push or Dual Mode.\nMainly for security concerns.",
          "type": "boolean"
        },
        "capacity": {
          "description": "Capacity is the sum of capacity resources for nodes in the cluster",
          "type": "object",
          "additionalProperties": {
            "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "string"
              }
            ],
            "x-kubernetes-int-or-string": true
          }
        },
        "clusterCIDR": {
          "description": "ClusterCIDR is the CIDR range of the cluster",
          "type": "string"
        },
        "conditions": {
          "description": "Conditions is an array of current cluster conditions.",
          "type": "array",
          "items": {
            "description": "Condition contains details for one aspect of the current state of this API Resource.\n---\nThis struct is intended for direct use as an array at the field path .status.conditions.  For example,\n\n\n\ttype FooStatus struct{\n\t    // Represents the observations of a foo's current state.\n\t    // Known .status.conditions.type are: \"Available\", \"Progressing\", and \"Degraded\"\n\t    // +patchMergeKey=type\n\t    // +patchStrategy=merge\n\t    // +listType=map\n\t    // +listMapKey=type\n\t    Conditions []metav1.Condition `json:\"conditions,omitempty\" patchStrategy:\"merge\" patchMergeKey:\"type\" protobuf:\"bytes,1,rep,name=conditions\"`\n\n\n\t    // other fields\n\t}",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "message",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                "type": "string",
                "maxLength": 32768
              },
              "observedGeneration": {
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "type": "integer",
                "format": "int64",
                "minimum": 0
              },
              "reason": {
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                "type": "string",
                "maxLength": 1024,
                "minLength": 1,
                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "type": "string",
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.\n---\nMany .condition.type values are consistent across resources like Available, but because arbitrary conditions can be\nuseful (see .node.status.conditions), the ability to deconflict is important.\nThe regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)",
                "type": "string",
                "maxLength": 316,
                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
              }
            },
            "additionalProperties": false
          }
        },
        "healthz": {
          "description": "Healthz indicates the healthz status of the cluster\nwhich is deprecated since Kubernetes v1.16. Please use Livez and Readyz instead.\nLeave it here only for compatibility.",
          "type": "boolean"
        },
        "heartbeatFrequencySeconds": {
          "description": "heartbeatFrequencySeconds is the frequency at which the agent reports current cluster status",
          "type": "integer",
          "format": "int64"
        },
        "k8sVersion": {
          "description": "k8sVersion is the Kubernetes version of the cluster",
          "type": "string"
        },
        "kubeBurst": {
          "description": "KubeBurst allows extra queries to accumulate when a client is exceeding its rate.\nUsed by deployer in Clusternet to control the burst to current child cluster.",
          "type": "integer",
          "format": "int32"
        },
        "kubeQPS": {
          "description": "KubeQPS controls the number of queries per second allowed for this connection.\nUsed by deployer in Clusternet to control the qps to current child cluster.",
          "type": "number"
        },
        "lastObservedTime": {
          "description": "lastObservedTime is the time when last status from the series was seen before last heartbeat.\nRFC 3339 date and time at which the object was acknowledged by the Clusternet Agent.",
          "type": "string",
          "format": "date-time"
        },
        "livez": {
          "description": "Livez indicates the livez status of the cluster",
          "type": "boolean"
        },
        "nodeStatistics": {
          "description": "NodeStatistics is the info summary of nodes in the cluster",
          "type": "object",
          "properties": {
            "lostNodes": {
              "description": "LostNodes is the number of states lost nodes in the cluster",
              "type": "integer",
              "format": "int32"
            },
            "notReadyNodes": {
              "description": "NotReadyNodes is the number of not ready nodes in the cluster",
              "type": "integer",
              "format": "int32"
            },
            "readyNodes": {
              "description": "ReadyNodes is the number of ready nodes in the cluster",
              "type": "integer",
              "format": "int32"
            },
            "unknownNodes": {
              "description": "UnknownNodes is the number of unknown nodes in the cluster",
              "type": "integer",
              "format": "int32"
            }
          },
          "additionalProperties": false
        },
        "platform": {
          "description": "platform indicates the running platform of the cluster",
          "type": "string"
        },
        "podStatistics": {
          "description": "PodStatistics is the info summary of pods in the cluster",
          "type": "object",
          "properties": {
            "runningPods": {
              "description": "RunningPods is the number of running pods in the cluster",
              "type": "integer",
              "format": "int32"
            },
            "totalPods": {
              "description": "TotalPods is the number of all pods in the cluster",
              "type": "integer",
              "format": "int32"
            }
          },
          "additionalProperties": false
        },
        "predictorAddress": {
          "description": "PredictorAddress shows the predictor address",
          "type": "string"
        },
        "predictorDirectAccess": {
          "description": "PredictorDirectAccess indicates whether the predictor can be accessed directly by clusternet-scheduler",
          "type": "boolean"
        },
        "predictorEnabled": {
          "description": "PredictorEnabled indicates whether predictor is enabled.",
          "type": "boolean"
        },
        "readyz": {
          "description": "Readyz indicates the readyz status of the cluster",
          "type": "boolean"
        },
        "resourceUsage": {
          "description": "ResourceUsage is the cpu(m) and memory(Mi) already used in the cluster",
          "type": "object",
          "properties": {
            "cpuUsage": {
              "description": "CpuUsage is the total cpu(m) already used in the whole cluster, k8s reserved not include",
              "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "x-kubernetes-int-or-string": true
            },
            "memoryUsage": {
              "description": "MemoryUsage is the total memory(Mi) already used in the whole cluster, k8s reserved not include",
              "pattern": "^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "string"
                }
              ],
              "x-kubernetes-int-or-string": true
            }
          },
          "additionalProperties": false
        },
        "serviceCIDR": {
          "description": "ServcieCIDR is the CIDR range of the services",
          "type": "string"
        },
        "useSocket": {
          "description": "UseSocket indicates whether to use socket proxy when connecting to child cluster.",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    }
  }
}
