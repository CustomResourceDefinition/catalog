{
  "description": "ApisixRoute is the Schema for the apisixroutes API.",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "ApisixRouteSpec is the spec definition for ApisixRouteSpec.",
      "type": "object",
      "properties": {
        "http": {
          "type": "array",
          "items": {
            "description": "ApisixRouteHTTP represents a single route in for HTTP traffic.",
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "authentication": {
                "description": "ApisixRouteAuthentication is the authentication-related\nconfiguration in ApisixRoute.",
                "type": "object",
                "required": [
                  "enable",
                  "type"
                ],
                "properties": {
                  "enable": {
                    "type": "boolean"
                  },
                  "jwtAuth": {
                    "description": "ApisixRouteAuthenticationJwtAuth is the jwt auth related\nconfiguration in ApisixRouteAuthentication.",
                    "type": "object",
                    "properties": {
                      "cookie": {
                        "type": "string"
                      },
                      "header": {
                        "type": "string"
                      },
                      "query": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "keyAuth": {
                    "description": "ApisixRouteAuthenticationKeyAuth is the keyAuth-related\nconfiguration in ApisixRouteAuthentication.",
                    "type": "object",
                    "properties": {
                      "header": {
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  },
                  "ldapAuth": {
                    "description": "ApisixRouteAuthenticationLDAPAuth is the LDAP auth related\nconfiguration in ApisixRouteAuthentication.",
                    "type": "object",
                    "properties": {
                      "base_dn": {
                        "type": "string"
                      },
                      "ldap_uri": {
                        "type": "string"
                      },
                      "uid": {
                        "type": "string"
                      },
                      "use_tls": {
                        "type": "boolean"
                      }
                    },
                    "additionalProperties": false
                  },
                  "type": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "backends": {
                "description": "Backends represents potential backends to proxy after the route\nrule matched. When number of backends are more than one, traffic-split\nplugin in APISIX will be used to split traffic based on the backend weight.",
                "type": "array",
                "items": {
                  "description": "ApisixRouteHTTPBackend represents an HTTP backend (a Kubernetes Service).",
                  "type": "object",
                  "required": [
                    "serviceName",
                    "servicePort"
                  ],
                  "properties": {
                    "resolveGranularity": {
                      "description": "The resolve granularity, can be \"endpoints\" or \"service\",\nwhen set to \"endpoints\", the pod ips will be used; other\nwise, the service ClusterIP or ExternalIP will be used,\ndefault is endpoints.",
                      "type": "string"
                    },
                    "serviceName": {
                      "description": "The name (short) of the service, note cross namespace is forbidden,\nso be sure the ApisixRoute and Service are in the same namespace.",
                      "type": "string"
                    },
                    "servicePort": {
                      "description": "The service port, could be the name or the port number.",
                      "anyOf": [
                        {
                          "type": "integer"
                        },
                        {
                          "type": "string"
                        }
                      ],
                      "x-kubernetes-int-or-string": true
                    },
                    "subset": {
                      "description": "Subset specifies a subset for the target Service. The subset should be pre-defined\nin ApisixUpstream about this service.",
                      "type": "string"
                    },
                    "weight": {
                      "description": "Weight of this backend.",
                      "type": "integer"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "match": {
                "description": "ApisixRouteHTTPMatch represents the match condition for hitting this route.",
                "type": "object",
                "required": [
                  "paths"
                ],
                "properties": {
                  "exprs": {
                    "description": "NginxVars represents generic match predicates,\nit uses Nginx variable systems, so any predicate\nlike headers, querystring and etc can be leveraged\nhere to match the route.\nFor instance, it can be:\nnginxVars:\n  - subject: \"$remote_addr\"\n    op: in\n    value:\n      - \"127.0.0.1\"\n      - \"10.0.5.11\"",
                    "type": "array",
                    "items": {
                      "description": "ApisixRouteHTTPMatchExpr represents a binary route match expression .",
                      "type": "object",
                      "required": [
                        "op",
                        "subject"
                      ],
                      "properties": {
                        "op": {
                          "description": "Op is the operator.",
                          "type": "string"
                        },
                        "set": {
                          "description": "Set is an array type object of the expression.\nIt should be used when the Op is \"in\" or \"not_in\";",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "subject": {
                          "description": "Subject is the expression subject, it can\nbe any string composed by literals and nginx\nvars.",
                          "type": "object",
                          "required": [
                            "name",
                            "scope"
                          ],
                          "properties": {
                            "name": {
                              "description": "The name of subject.",
                              "type": "string"
                            },
                            "scope": {
                              "description": "The subject scope, can be:\nScopeQuery, ScopeHeader, ScopePath\nwhen subject is ScopePath, Name field\nwill be ignored.",
                              "type": "string"
                            }
                          },
                          "additionalProperties": false
                        },
                        "value": {
                          "description": "Value is the normal type object for the expression,\nit should be used when the Op is not \"in\" and \"not_in\".\nSet and Value are exclusive so only of them can be set\nin the same time.",
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    }
                  },
                  "filter_func": {
                    "description": "Matches based on a user-defined filtering function.\nThese functions can accept an input parameter `vars`\nwhich can be used to access the Nginx variables.",
                    "type": "string"
                  },
                  "hosts": {
                    "description": "HTTP Host predicates, host can be a wildcard domain or\nan exact domain. For wildcard domain, only one generic\nlevel is allowed, for instance, \"*.foo.com\" is valid but\n\"*.*.foo.com\" is not.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "methods": {
                    "description": "HTTP request method predicates.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "paths": {
                    "description": "URI path predicates, at least one path should be\nconfigured, path could be exact or prefix, for prefix path,\nappend \"*\" after it, for instance, \"/foo*\".",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "remoteAddrs": {
                    "description": "Remote address predicates, items can be valid IPv4 address\nor IPv6 address or CIDR.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              },
              "name": {
                "description": "The rule name, cannot be empty.",
                "type": "string"
              },
              "plugin_config_name": {
                "type": "string"
              },
              "plugin_config_namespace": {
                "description": "By default, PluginConfigNamespace will be the same as the namespace of ApisixRoute",
                "type": "string"
              },
              "plugins": {
                "type": "array",
                "items": {
                  "description": "ApisixRoutePlugin represents an APISIX plugin.",
                  "type": "object",
                  "required": [
                    "enable",
                    "name"
                  ],
                  "properties": {
                    "config": {
                      "description": "Plugin configuration.",
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "enable": {
                      "description": "Whether this plugin is in use, default is true.",
                      "type": "boolean",
                      "default": true
                    },
                    "name": {
                      "description": "The plugin name.",
                      "type": "string"
                    },
                    "secretRef": {
                      "description": "Plugin configuration secretRef.",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "priority": {
                "description": "Route priority, when multiple routes contains\nsame URI path (for path matching), route with\nhigher priority will take effect.",
                "type": "integer"
              },
              "timeout": {
                "description": "UpstreamTimeout is settings for the read, send and connect to the upstream.",
                "type": "object",
                "properties": {
                  "connect": {
                    "type": "string"
                  },
                  "read": {
                    "type": "string"
                  },
                  "send": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "upstreams": {
                "description": "Upstreams refer to ApisixUpstream CRD",
                "type": "array",
                "items": {
                  "description": "ApisixRouteUpstreamReference contains a ApisixUpstream CRD reference",
                  "type": "object",
                  "properties": {
                    "name": {
                      "type": "string"
                    },
                    "weight": {
                      "type": "integer"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "websocket": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        "ingressClassName": {
          "type": "string"
        },
        "stream": {
          "type": "array",
          "items": {
            "description": "ApisixRouteStream is the configuration for level 4 route",
            "type": "object",
            "required": [
              "backend",
              "match",
              "name",
              "protocol"
            ],
            "properties": {
              "backend": {
                "description": "ApisixRouteStreamBackend represents a TCP backend (a Kubernetes Service).",
                "type": "object",
                "required": [
                  "serviceName",
                  "servicePort"
                ],
                "properties": {
                  "resolveGranularity": {
                    "description": "The resolve granularity, can be \"endpoints\" or \"service\",\nwhen set to \"endpoints\", the pod ips will be used; other\nwise, the service ClusterIP or ExternalIP will be used,\ndefault is endpoints.",
                    "type": "string"
                  },
                  "serviceName": {
                    "description": "The name (short) of the service, note cross namespace is forbidden,\nso be sure the ApisixRoute and Service are in the same namespace.",
                    "type": "string"
                  },
                  "servicePort": {
                    "description": "The service port, could be the name or the port number.",
                    "anyOf": [
                      {
                        "type": "integer"
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "x-kubernetes-int-or-string": true
                  },
                  "subset": {
                    "description": "Subset specifies a subset for the target Service. The subset should be pre-defined\nin ApisixUpstream about this service.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "match": {
                "description": "ApisixRouteStreamMatch represents the match conditions of stream route.",
                "type": "object",
                "required": [
                  "ingressPort"
                ],
                "properties": {
                  "host": {
                    "type": "string"
                  },
                  "ingressPort": {
                    "description": "IngressPort represents the port listening on the Ingress proxy server.\nIt should be pre-defined as APISIX doesn't support dynamic listening.",
                    "type": "integer",
                    "format": "int32"
                  }
                },
                "additionalProperties": false
              },
              "name": {
                "description": "The rule name cannot be empty.",
                "type": "string"
              },
              "plugins": {
                "type": "array",
                "items": {
                  "description": "ApisixRoutePlugin represents an APISIX plugin.",
                  "type": "object",
                  "required": [
                    "enable",
                    "name"
                  ],
                  "properties": {
                    "config": {
                      "description": "Plugin configuration.",
                      "x-kubernetes-preserve-unknown-fields": true
                    },
                    "enable": {
                      "description": "Whether this plugin is in use, default is true.",
                      "type": "boolean",
                      "default": true
                    },
                    "name": {
                      "description": "The plugin name.",
                      "type": "string"
                    },
                    "secretRef": {
                      "description": "Plugin configuration secretRef.",
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "protocol": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        }
      },
      "additionalProperties": false
    },
    "status": {
      "description": "ApisixStatus is the status report for Apisix ingress Resources",
      "type": "object",
      "properties": {
        "conditions": {
          "type": "array",
          "items": {
            "description": "Condition contains details for one aspect of the current state of this API Resource.",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "message",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                "type": "string",
                "maxLength": 32768
              },
              "observedGeneration": {
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "type": "integer",
                "format": "int64",
                "minimum": 0
              },
              "reason": {
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                "type": "string",
                "maxLength": 1024,
                "minLength": 1,
                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "type": "string",
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                "type": "string",
                "maxLength": 316,
                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
              }
            },
            "additionalProperties": false
          }
        }
      },
      "additionalProperties": false
    }
  }
}
