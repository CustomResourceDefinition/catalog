{
  "description": "LinstorSatellite is the Schema for the linstorsatellites API",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "LinstorSatelliteSpec defines the desired state of LinstorSatellite",
      "type": "object",
      "required": [
        "clusterRef"
      ],
      "properties": {
        "clusterRef": {
          "description": "ClusterRef references the LinstorCluster used to create this LinstorSatellite.",
          "type": "object",
          "properties": {
            "caReference": {
              "description": "CAReference configures the CA certificate to use when validating TLS certificates.\nIf not set, the TLS secret is expected to contain a \"ca.crt\" containing the CA certificate.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "key": {
                  "description": "Key to select in the resource.\nDefaults to ca.crt if not specified.",
                  "type": "string",
                  "default": "ca.crt"
                },
                "kind": {
                  "description": "Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.",
                  "type": "string",
                  "default": "Secret",
                  "enum": [
                    "ConfigMap",
                    "Secret"
                  ]
                },
                "name": {
                  "description": "Name of the resource containing the CA Certificate.",
                  "type": "string"
                },
                "optional": {
                  "description": "Optional specifies whether the resource and its key must exist.",
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            },
            "clientSecretName": {
              "description": "ClientSecretName references the secret used by the operator to validate the https endpoint.",
              "type": "string"
            },
            "externalController": {
              "description": "ExternalController references an external controller.\nWhen set, the Operator uses the external cluster to register satellites.",
              "type": "object",
              "required": [
                "url"
              ],
              "properties": {
                "url": {
                  "description": "URL of the external controller.",
                  "type": "string",
                  "minLength": 3
                }
              },
              "additionalProperties": false
            },
            "name": {
              "description": "Name of the LinstorCluster resource controlling this satellite.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "deletionPolicy": {
          "description": "DeletionPolicy configures the way LinstorSatellite resources are deleted.\n\nA LinstorSatellite may be deleted because:\n* It no longer matches the affinity and node selector of the LinstorCluster resource.\n* The node it references has been removed from Kubernetes.\n* It was manually deleted outside the Operator.\n\nA LinstorSatellite may store the last copy of a volume, in which case it is not desirable to unconditionally remove\nthe satellite from the cluster. For this reason, the following deletion policies exist:\n\n* DeletionPolicyEvacuate will start evacuation of the LINSTOR Satellite and wait until it completes before removing the LinstorSatellite object, comparable to the \"linstor node evacuate\" command.\n* DeletionPolicyRetain will retain the LINSTOR Satellite, keeping it registered in LINSTOR, but removing associated Kubernetes resources.\n* DeletionPolicyDelete will remove the LINSTOR Satellite from the LINSTOR Cluster without prior eviction, comparable to the \"linstor node lost\" command.",
          "type": "string",
          "default": "Retain",
          "enum": [
            "Evacuate",
            "Retain",
            "Delete"
          ]
        },
        "evacuationStrategy": {
          "description": "EvacuationStrategy configures the evacuation of volumes from a Satellite when DeletionPolicy \"Evacuate\" is used.",
          "type": "object",
          "properties": {
            "attachedVolumeReattachTimeout": {
              "description": "AttachedVolumeReattachTimeout configures how long evacuation waits for attached volumes to reattach on\ndifferent nodes. Setting this to 0 disable this evacuation step.",
              "type": "string",
              "default": "5m"
            },
            "unattachedVolumeAttachTimeout": {
              "description": "UnattachedVolumeAttachTimeout configures how long evacuation waits for unattached volumes to attach on\ndifferent nodes. Setting this to 0 disable this evacuation step.",
              "type": "string",
              "default": "5m"
            }
          },
          "additionalProperties": false
        },
        "internalTLS": {
          "description": "InternalTLS configures secure communication for the LINSTOR Satellite.\n\nIf set, the control traffic between LINSTOR Controller and Satellite will be encrypted using mTLS.\nThe Controller will use the client key from `LinstorCluster.spec.internalTLS` when connecting.",
          "type": "object",
          "properties": {
            "caReference": {
              "description": "CAReference configures the CA certificate to use when validating TLS certificates.\nIf not set, the TLS secret is expected to contain a \"ca.crt\" containing the CA certificate.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "key": {
                  "description": "Key to select in the resource.\nDefaults to ca.crt if not specified.",
                  "type": "string",
                  "default": "ca.crt"
                },
                "kind": {
                  "description": "Kind of the resource containing the CA Certificate, either a ConfigMap or Secret.",
                  "type": "string",
                  "default": "Secret",
                  "enum": [
                    "ConfigMap",
                    "Secret"
                  ]
                },
                "name": {
                  "description": "Name of the resource containing the CA Certificate.",
                  "type": "string"
                },
                "optional": {
                  "description": "Optional specifies whether the resource and its key must exist.",
                  "type": "boolean"
                }
              },
              "additionalProperties": false
            },
            "certManager": {
              "description": "CertManager references a cert-manager Issuer or ClusterIssuer.\nIf set, a Certificate resource will be created, provisioning the secret references in SecretName using the\nissuer configured here.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "group": {
                  "description": "Group of the resource being referred to.",
                  "type": "string"
                },
                "kind": {
                  "description": "Kind of the resource being referred to.",
                  "type": "string"
                },
                "name": {
                  "description": "Name of the resource being referred to.",
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            "secretName": {
              "description": "SecretName references a secret holding the TLS key and certificates.",
              "type": "string"
            },
            "tlsHandshakeDaemon": {
              "description": "TLSHandshakeDaemon enables tlshd for establishing TLS sessions for use by DRBD.\n\nIf enabled, adds a new sidecar to the LINSTOR Satellite that runs the tlshd handshake daemon.\nThe daemon uses the TLS certificate and key to establish secure connections on behalf of DRBD.",
              "type": "boolean"
            }
          },
          "additionalProperties": false,
          "nullable": true
        },
        "ipFamilies": {
          "description": "IPFamilies configures the IP Family (IPv4 or IPv6) to use to connect to the LINSTOR Satellite.\n\nIf set, the control traffic between LINSTOR Controller and Satellite will use only the given IP Family.\nIf not set, the Operator will configure all families found in the Satellites Pods' Status.",
          "type": "array",
          "items": {
            "description": "IPFamily represents the IP Family (IPv4 or IPv6).",
            "type": "string",
            "enum": [
              "IPv4",
              "IPv6"
            ]
          }
        },
        "patches": {
          "description": "Patches is a list of kustomize patches to apply.\n\nSee https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patches/ for how to create patches.",
          "type": "array",
          "items": {
            "description": "Patch represent either a Strategic Merge Patch or a JSON patch and its targets.",
            "type": "object",
            "required": [
              "patch"
            ],
            "properties": {
              "options": {
                "description": "Options is a list of options for the patch",
                "type": "object",
                "properties": {
                  "allowKindChange": {
                    "description": "AllowKindChange allows kind changes to the resource.",
                    "type": "boolean"
                  },
                  "allowNameChange": {
                    "description": "AllowNameChange allows name changes to the resource.",
                    "type": "boolean"
                  }
                },
                "additionalProperties": false
              },
              "patch": {
                "description": "Patch is the content of a patch.",
                "type": "string",
                "minLength": 1
              },
              "target": {
                "description": "Target points to the resources that the patch is applied to",
                "type": "object",
                "properties": {
                  "annotationSelector": {
                    "description": "AnnotationSelector is a string that follows the label selection expression\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api\nIt matches against the resource annotations.",
                    "type": "string"
                  },
                  "group": {
                    "type": "string"
                  },
                  "kind": {
                    "type": "string"
                  },
                  "labelSelector": {
                    "description": "LabelSelector is a string that follows the label selection expression\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#api\nIt matches against the resource labels.",
                    "type": "string"
                  },
                  "name": {
                    "description": "Name of the resource.",
                    "type": "string"
                  },
                  "namespace": {
                    "description": "Namespace the resource belongs to, if it can belong to a namespace.",
                    "type": "string"
                  },
                  "version": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        },
        "properties": {
          "description": "Properties is a list of properties to set on the node.",
          "type": "array",
          "items": {
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "expandFrom": {
                "description": "ExpandFrom can reference multiple resource fields at once.\nIt either sets the property to an aggregate value based on matched resource fields, or expands to multiple\nproperties.",
                "type": "object",
                "required": [
                  "nodeFieldRef"
                ],
                "properties": {
                  "delimiter": {
                    "description": "Delimiter used to join multiple key and value pairs together.",
                    "type": "string"
                  },
                  "nameTemplate": {
                    "description": "NameTemplate defines how the property key is expanded.\nIf set, the template is appended to the defined property name, creating multiple properties instead of one\naggregate.\n* $1 is replaced with the matched key.\n* $2 is replaced with the matched value.",
                    "type": "string"
                  },
                  "nodeFieldRef": {
                    "description": "Select a field of the node. Supports `metadata.name`, `metadata.labels['\u003cKEY\u003e']`, `metadata.annotations['\u003cKEY\u003e']`.",
                    "type": "string",
                    "minLength": 1
                  },
                  "valueTemplate": {
                    "description": "ValueTemplate defines how the property value is expanded.\n* $1 is replaced with the matched key.\n* $2 is replaced with the matched value.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "name": {
                "description": "Name of the property to set.",
                "type": "string",
                "minLength": 1
              },
              "optional": {
                "description": "Optional values are only set if they have a non-empty value",
                "type": "boolean"
              },
              "value": {
                "description": "Value to set the property to.",
                "type": "string"
              },
              "valueFrom": {
                "description": "ValueFrom sets the value from an existing resource.",
                "type": "object",
                "required": [
                  "nodeFieldRef"
                ],
                "properties": {
                  "nodeFieldRef": {
                    "description": "Select a field of the node. Supports `metadata.name`, `metadata.labels['\u003cKEY\u003e']`, `metadata.annotations['\u003cKEY\u003e']`.",
                    "type": "string",
                    "minLength": 1
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map"
        },
        "repository": {
          "description": "Repository used to pull workload images.",
          "type": "string"
        },
        "storagePools": {
          "description": "StoragePools is a list of storage pools to configure on the node.",
          "type": "array",
          "items": {
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "filePool": {
                "description": "Configures a file system based storage pool, allocating a regular file per volume.",
                "type": "object",
                "properties": {
                  "directory": {
                    "description": "Directory is the path to the host directory used to store volume data.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "fileThinPool": {
                "description": "Configures a file system based storage pool, allocating a sparse file per volume.",
                "type": "object",
                "properties": {
                  "directory": {
                    "description": "Directory is the path to the host directory used to store volume data.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "lvmPool": {
                "description": "Configures a LVM Volume Group as storage pool.",
                "type": "object",
                "properties": {
                  "volumeGroup": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "lvmThinPool": {
                "description": "Configures a LVM Thin Pool as storage pool.",
                "type": "object",
                "properties": {
                  "thinPool": {
                    "description": "ThinPool is the name of the thinpool LV (without VG prefix).",
                    "type": "string"
                  },
                  "volumeGroup": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "name": {
                "description": "Name of the storage pool in linstor.",
                "type": "string",
                "minLength": 3
              },
              "properties": {
                "description": "Properties to set on the storage pool.",
                "type": "array",
                "items": {
                  "type": "object",
                  "required": [
                    "name"
                  ],
                  "properties": {
                    "expandFrom": {
                      "description": "ExpandFrom can reference multiple resource fields at once.\nIt either sets the property to an aggregate value based on matched resource fields, or expands to multiple\nproperties.",
                      "type": "object",
                      "required": [
                        "nodeFieldRef"
                      ],
                      "properties": {
                        "delimiter": {
                          "description": "Delimiter used to join multiple key and value pairs together.",
                          "type": "string"
                        },
                        "nameTemplate": {
                          "description": "NameTemplate defines how the property key is expanded.\nIf set, the template is appended to the defined property name, creating multiple properties instead of one\naggregate.\n* $1 is replaced with the matched key.\n* $2 is replaced with the matched value.",
                          "type": "string"
                        },
                        "nodeFieldRef": {
                          "description": "Select a field of the node. Supports `metadata.name`, `metadata.labels['\u003cKEY\u003e']`, `metadata.annotations['\u003cKEY\u003e']`.",
                          "type": "string",
                          "minLength": 1
                        },
                        "valueTemplate": {
                          "description": "ValueTemplate defines how the property value is expanded.\n* $1 is replaced with the matched key.\n* $2 is replaced with the matched value.",
                          "type": "string"
                        }
                      },
                      "additionalProperties": false
                    },
                    "name": {
                      "description": "Name of the property to set.",
                      "type": "string",
                      "minLength": 1
                    },
                    "optional": {
                      "description": "Optional values are only set if they have a non-empty value",
                      "type": "boolean"
                    },
                    "value": {
                      "description": "Value to set the property to.",
                      "type": "string"
                    },
                    "valueFrom": {
                      "description": "ValueFrom sets the value from an existing resource.",
                      "type": "object",
                      "required": [
                        "nodeFieldRef"
                      ],
                      "properties": {
                        "nodeFieldRef": {
                          "description": "Select a field of the node. Supports `metadata.name`, `metadata.labels['\u003cKEY\u003e']`, `metadata.annotations['\u003cKEY\u003e']`.",
                          "type": "string",
                          "minLength": 1
                        }
                      },
                      "additionalProperties": false
                    }
                  },
                  "additionalProperties": false
                },
                "x-kubernetes-list-map-keys": [
                  "name"
                ],
                "x-kubernetes-list-type": "map"
              },
              "source": {
                "type": "object",
                "properties": {
                  "hostDevices": {
                    "description": "HostDevices is a list of device paths used to configure the given pool.",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              },
              "zfsPool": {
                "description": "Configures a ZFS system based storage pool, allocating zvols from the given zpool.",
                "type": "object",
                "properties": {
                  "zPool": {
                    "description": "ZPool is the name of the ZFS zpool.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              },
              "zfsThinPool": {
                "description": "Configures a ZFS system based storage pool, allocating sparse zvols from the given zpool.",
                "type": "object",
                "properties": {
                  "zPool": {
                    "description": "ZPool is the name of the ZFS zpool.",
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        }
      },
      "additionalProperties": false
    },
    "status": {
      "description": "LinstorSatelliteStatus defines the observed state of LinstorSatellite",
      "type": "object",
      "properties": {
        "availableCapacityBytes": {
          "description": "The number of bytes in total in all storage pools on this Satellite.",
          "type": "integer",
          "format": "int64"
        },
        "capacity": {
          "description": "Capacity mirrors the information from TotalCapacityBytes and FreeCapacityBytes in a human-readable string.",
          "type": "string"
        },
        "conditions": {
          "description": "Current LINSTOR Satellite state",
          "type": "array",
          "items": {
            "description": "Condition contains details for one aspect of the current state of this API Resource.",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "message",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                "type": "string",
                "maxLength": 32768
              },
              "observedGeneration": {
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "type": "integer",
                "format": "int64",
                "minimum": 0
              },
              "reason": {
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                "type": "string",
                "maxLength": 1024,
                "minLength": 1,
                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "type": "string",
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                "type": "string",
                "maxLength": 316,
                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
              }
            },
            "additionalProperties": false
          },
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map"
        },
        "deviceLayers": {
          "description": "DeviceLayers lists the device layers (LUKS, CACHE, etc...) this Satellite supports.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "freeCapacityBytes": {
          "description": "The number of bytes free in all storage pools on this Satellite.",
          "type": "integer",
          "format": "int64"
        },
        "numberOfSnapshots": {
          "description": "The number of snapshots on this Satellite.",
          "type": "integer",
          "format": "int32"
        },
        "numberOfVolumes": {
          "description": "The number of volumes on this Satellite.",
          "type": "integer",
          "format": "int32"
        },
        "storageProviders": {
          "description": "StorageProviders lists the storage providers (LVM, ZFS, etc...) this Satellite supports.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    }
  }
}
