{
  "description": "APIServer holds configuration (like serving certificates, client CA and CORS domains)\nshared by all API servers in the system, among them especially kube-apiserver\nand openshift-apiserver. The canonical name of an instance is 'cluster'.\n\nCompatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "spec holds user settable values for configuration",
      "type": "object",
      "properties": {
        "additionalCORSAllowedOrigins": {
          "description": "additionalCORSAllowedOrigins lists additional, user-defined regular expressions describing hosts for which the\nAPI server allows access using the CORS headers. This may be needed to access the API and the integrated OAuth\nserver from JavaScript applications.\nThe values are regular expressions that correspond to the Golang regular expression language.",
          "type": "array",
          "items": {
            "type": "string"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "audit": {
          "description": "audit specifies the settings for audit configuration to be applied to all OpenShift-provided\nAPI servers in the cluster.",
          "type": "object",
          "default": {
            "profile": "Default"
          },
          "properties": {
            "customRules": {
              "description": "customRules specify profiles per group. These profile take precedence over the\ntop-level profile field if they apply. They are evaluation from top to bottom and\nthe first one that matches, applies.",
              "type": "array",
              "items": {
                "description": "AuditCustomRule describes a custom rule for an audit profile that takes precedence over\nthe top-level profile.",
                "type": "object",
                "required": [
                  "group",
                  "profile"
                ],
                "properties": {
                  "group": {
                    "description": "group is a name of group a request user must be member of in order to this profile to apply.",
                    "type": "string",
                    "minLength": 1
                  },
                  "profile": {
                    "description": "profile specifies the name of the desired audit policy configuration to be deployed to\nall OpenShift-provided API servers in the cluster.\n\nThe following profiles are provided:\n- Default: the existing default policy.\n- WriteRequestBodies: like 'Default', but logs request and response HTTP payloads for\nwrite requests (create, update, patch).\n- AllRequestBodies: like 'WriteRequestBodies', but also logs request and response\nHTTP payloads for read requests (get, list).\n- None: no requests are logged at all, not even oauthaccesstokens and oauthauthorizetokens.\n\nIf unset, the 'Default' profile is used as the default.",
                    "type": "string",
                    "enum": [
                      "Default",
                      "WriteRequestBodies",
                      "AllRequestBodies",
                      "None"
                    ]
                  }
                },
                "additionalProperties": false
              },
              "x-kubernetes-list-map-keys": [
                "group"
              ],
              "x-kubernetes-list-type": "map"
            },
            "profile": {
              "description": "profile specifies the name of the desired top-level audit profile to be applied to all requests\nsent to any of the OpenShift-provided API servers in the cluster (kube-apiserver,\nopenshift-apiserver and oauth-apiserver), with the exception of those requests that match\none or more of the customRules.\n\nThe following profiles are provided:\n- Default: default policy which means MetaData level logging with the exception of events\n  (not logged at all), oauthaccesstokens and oauthauthorizetokens (both logged at RequestBody\n  level).\n- WriteRequestBodies: like 'Default', but logs request and response HTTP payloads for\nwrite requests (create, update, patch).\n- AllRequestBodies: like 'WriteRequestBodies', but also logs request and response\nHTTP payloads for read requests (get, list).\n- None: no requests are logged at all, not even oauthaccesstokens and oauthauthorizetokens.\n\nWarning: It is not recommended to disable audit logging by using the `None` profile unless you\nare fully aware of the risks of not logging data that can be beneficial when troubleshooting issues.\nIf you disable audit logging and a support situation arises, you might need to enable audit logging\nand reproduce the issue in order to troubleshoot properly.\n\nIf unset, the 'Default' profile is used as the default.",
              "type": "string",
              "default": "Default",
              "enum": [
                "Default",
                "WriteRequestBodies",
                "AllRequestBodies",
                "None"
              ]
            }
          },
          "additionalProperties": false
        },
        "clientCA": {
          "description": "clientCA references a ConfigMap containing a certificate bundle for the signers that will be recognized for\nincoming client certificates in addition to the operator managed signers. If this is empty, then only operator managed signers are valid.\nYou usually only have to set this if you have your own PKI you wish to honor client certificates from.\nThe ConfigMap must exist in the openshift-config namespace and contain the following required fields:\n- ConfigMap.Data[\"ca-bundle.crt\"] - CA bundle.",
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "name is the metadata.name of the referenced config map",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "encryption": {
          "description": "encryption allows the configuration of encryption of resources at the datastore layer.",
          "type": "object",
          "properties": {
            "type": {
              "description": "type defines what encryption type should be used to encrypt resources at the datastore layer.\nWhen this field is unset (i.e. when it is set to the empty string), identity is implied.\nThe behavior of unset can and will change over time.  Even if encryption is enabled by default,\nthe meaning of unset may change to a different encryption type based on changes in best practices.\n\nWhen encryption is enabled, all sensitive resources shipped with the platform are encrypted.\nThis list of sensitive resources can and will change over time.  The current authoritative list is:\n\n  1. secrets\n  2. configmaps\n  3. routes.route.openshift.io\n  4. oauthaccesstokens.oauth.openshift.io\n  5. oauthauthorizetokens.oauth.openshift.io",
              "type": "string",
              "enum": [
                "",
                "identity",
                "aescbc",
                "aesgcm",
                "KMS"
              ]
            }
          },
          "additionalProperties": false
        },
        "servingCerts": {
          "description": "servingCert is the TLS cert info for serving secure traffic. If not specified, operator managed certificates\nwill be used for serving secure traffic.",
          "type": "object",
          "properties": {
            "namedCertificates": {
              "description": "namedCertificates references secrets containing the TLS cert info for serving secure traffic to specific hostnames.\nIf no named certificates are provided, or no named certificates match the server name as understood by a client,\nthe defaultServingCertificate will be used.",
              "type": "array",
              "maxItems": 32,
              "items": {
                "description": "APIServerNamedServingCert maps a server DNS name, as understood by a client, to a certificate.",
                "type": "object",
                "properties": {
                  "names": {
                    "description": "names is a optional list of explicit DNS names (leading wildcards allowed) that should use this certificate to\nserve secure traffic. If no names are provided, the implicit names will be extracted from the certificates.\nExact names trump over wildcard names. Explicit names defined here trump over extracted implicit names.",
                    "type": "array",
                    "maxItems": 64,
                    "items": {
                      "type": "string"
                    },
                    "x-kubernetes-list-type": "atomic"
                  },
                  "servingCertificate": {
                    "description": "servingCertificate references a kubernetes.io/tls type secret containing the TLS cert info for serving secure traffic.\nThe secret must exist in the openshift-config namespace and contain the following required fields:\n- Secret.Data[\"tls.key\"] - TLS private key.\n- Secret.Data[\"tls.crt\"] - TLS certificate.",
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "description": "name is the metadata.name of the referenced secret",
                        "type": "string"
                      }
                    },
                    "additionalProperties": false
                  }
                },
                "additionalProperties": false
              },
              "x-kubernetes-list-type": "atomic"
            }
          },
          "additionalProperties": false
        },
        "tlsSecurityProfile": {
          "description": "tlsSecurityProfile specifies settings for TLS connections for externally exposed servers.\n\nWhen omitted, this means no opinion and the platform is left to choose a reasonable default, which is subject to change over time.\nThe current default is the Intermediate profile.",
          "type": "object",
          "properties": {
            "custom": {
              "description": "custom is a user-defined TLS security profile. Be extremely careful using a custom\nprofile as invalid configurations can be catastrophic. An example custom profile\nlooks like this:\n\n  minTLSVersion: VersionTLS11\n  ciphers:\n    - ECDHE-ECDSA-CHACHA20-POLY1305\n    - ECDHE-RSA-CHACHA20-POLY1305\n    - ECDHE-RSA-AES128-GCM-SHA256\n    - ECDHE-ECDSA-AES128-GCM-SHA256",
              "type": "object",
              "properties": {
                "ciphers": {
                  "description": "ciphers is used to specify the cipher algorithms that are negotiated\nduring the TLS handshake. Operators may remove entries that their operands\ndo not support. For example, to use only ECDHE-RSA-AES128-GCM-SHA256 (yaml):\n\n  ciphers:\n    - ECDHE-RSA-AES128-GCM-SHA256\n\nTLS 1.3 cipher suites (e.g. TLS_AES_128_GCM_SHA256) are not configurable\nand are always enabled when TLS 1.3 is negotiated.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "x-kubernetes-list-type": "atomic"
                },
                "minTLSVersion": {
                  "description": "minTLSVersion is used to specify the minimal version of the TLS protocol\nthat is negotiated during the TLS handshake. For example, to use TLS\nversions 1.1, 1.2 and 1.3 (yaml):\n\n  minTLSVersion: VersionTLS11",
                  "type": "string",
                  "enum": [
                    "VersionTLS10",
                    "VersionTLS11",
                    "VersionTLS12",
                    "VersionTLS13"
                  ]
                }
              },
              "additionalProperties": false,
              "nullable": true
            },
            "intermediate": {
              "description": "intermediate is a TLS profile for use when you do not need compatibility with\nlegacy clients and want to remain highly secure while being compatible with\nmost clients currently in use.\n\nThis profile is equivalent to a Custom profile specified as:\n  minTLSVersion: VersionTLS12\n  ciphers:\n    - TLS_AES_128_GCM_SHA256\n    - TLS_AES_256_GCM_SHA384\n    - TLS_CHACHA20_POLY1305_SHA256\n    - ECDHE-ECDSA-AES128-GCM-SHA256\n    - ECDHE-RSA-AES128-GCM-SHA256\n    - ECDHE-ECDSA-AES256-GCM-SHA384\n    - ECDHE-RSA-AES256-GCM-SHA384\n    - ECDHE-ECDSA-CHACHA20-POLY1305\n    - ECDHE-RSA-CHACHA20-POLY1305",
              "type": "object",
              "nullable": true
            },
            "modern": {
              "description": "modern is a TLS security profile for use with clients that support TLS 1.3 and\ndo not need backward compatibility for older clients.\n\nThis profile is equivalent to a Custom profile specified as:\n  minTLSVersion: VersionTLS13\n  ciphers:\n    - TLS_AES_128_GCM_SHA256\n    - TLS_AES_256_GCM_SHA384\n    - TLS_CHACHA20_POLY1305_SHA256",
              "type": "object",
              "nullable": true
            },
            "old": {
              "description": "old is a TLS profile for use when services need to be accessed by very old\nclients or libraries and should be used only as a last resort.\n\nThis profile is equivalent to a Custom profile specified as:\n  minTLSVersion: VersionTLS10\n  ciphers:\n    - TLS_AES_128_GCM_SHA256\n    - TLS_AES_256_GCM_SHA384\n    - TLS_CHACHA20_POLY1305_SHA256\n    - ECDHE-ECDSA-AES128-GCM-SHA256\n    - ECDHE-RSA-AES128-GCM-SHA256\n    - ECDHE-ECDSA-AES256-GCM-SHA384\n    - ECDHE-RSA-AES256-GCM-SHA384\n    - ECDHE-ECDSA-CHACHA20-POLY1305\n    - ECDHE-RSA-CHACHA20-POLY1305\n    - ECDHE-ECDSA-AES128-SHA256\n    - ECDHE-RSA-AES128-SHA256\n    - ECDHE-ECDSA-AES128-SHA\n    - ECDHE-RSA-AES128-SHA\n    - ECDHE-ECDSA-AES256-SHA\n    - ECDHE-RSA-AES256-SHA\n    - AES128-GCM-SHA256\n    - AES256-GCM-SHA384\n    - AES128-SHA256\n    - AES128-SHA\n    - AES256-SHA\n    - DES-CBC3-SHA",
              "type": "object",
              "nullable": true
            },
            "type": {
              "description": "type is one of Old, Intermediate, Modern or Custom. Custom provides the\nability to specify individual TLS security profile parameters.\n\nThe profiles are based on version 5.7 of the Mozilla Server Side TLS\nconfiguration guidelines. The cipher lists consist of the configuration's\n\"ciphersuites\" followed by the Go-specific \"ciphers\" from the guidelines.\nSee: https://ssl-config.mozilla.org/guidelines/5.7.json\n\nThe profiles are intent based, so they may change over time as new ciphers are\ndeveloped and existing ciphers are found to be insecure. Depending on\nprecisely which ciphers are available to a process, the list may be reduced.",
              "type": "string",
              "enum": [
                "Old",
                "Intermediate",
                "Modern",
                "Custom"
              ]
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "status": {
      "description": "status holds observed values from the cluster. They may not be overridden.",
      "type": "object"
    }
  }
}
