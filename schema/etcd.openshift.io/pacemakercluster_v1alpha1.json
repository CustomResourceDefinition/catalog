{
  "description": "PacemakerCluster represents the current state of the pacemaker cluster as reported by the pcs status command.\nPacemakerCluster is a cluster-scoped singleton resource. The name of this instance is \"cluster\". This\nresource provides a view into the health and status of a pacemaker-managed cluster in Two Node OpenShift with Fencing deployments.\n\nCompatibility level 4: No compatibility is provided, the API can change at any point for any reason. These capabilities should not be used by applications needing long term support.",
  "type": "object",
  "required": [
    "metadata"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "status": {
      "description": "status contains the actual pacemaker cluster status information collected from the cluster.\nThe goal of this status is to be able to quickly identify if pacemaker is in a healthy state.\nIn Two Node OpenShift with Fencing, a healthy pacemaker cluster has 2 nodes, both of which have healthy kubelet, etcd, and fencing resources.\nThis field is optional on creation - the status collector populates it immediately after creating\nthe resource via the status subresource.",
      "type": "object",
      "required": [
        "conditions",
        "lastUpdated",
        "nodes"
      ],
      "properties": {
        "conditions": {
          "description": "conditions represent the observations of the pacemaker cluster's current state.\nKnown condition types are: \"Healthy\", \"InService\", \"NodeCountAsExpected\".\nThe \"Healthy\" condition is an aggregate that tracks the overall health of the cluster.\nThe \"InService\" condition tracks whether the cluster is in service (not in maintenance mode).\nThe \"NodeCountAsExpected\" condition tracks whether the expected number of nodes are present.\nEach of these conditions is required, so the array must contain at least 3 items.",
          "type": "array",
          "maxItems": 8,
          "minItems": 3,
          "items": {
            "description": "Condition contains details for one aspect of the current state of this API Resource.",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "message",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                "type": "string",
                "maxLength": 32768
              },
              "observedGeneration": {
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "type": "integer",
                "format": "int64",
                "minimum": 0
              },
              "reason": {
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                "type": "string",
                "maxLength": 1024,
                "minLength": 1,
                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "type": "string",
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                "type": "string",
                "maxLength": 316,
                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
              }
            },
            "additionalProperties": false
          },
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-validations": [
            {
              "rule": "self.exists(c, c.type == 'Healthy')",
              "message": "conditions must contain a condition of type Healthy"
            },
            {
              "rule": "self.exists(c, c.type == 'InService')",
              "message": "conditions must contain a condition of type InService"
            },
            {
              "rule": "self.exists(c, c.type == 'NodeCountAsExpected')",
              "message": "conditions must contain a condition of type NodeCountAsExpected"
            }
          ]
        },
        "lastUpdated": {
          "description": "lastUpdated is the timestamp when this status was last updated. This is useful for identifying\nstale status reports. It must be a valid timestamp in RFC3339 format. Once set, this field cannot\nbe removed and cannot be set to an earlier timestamp than the current value.",
          "type": "string",
          "format": "date-time"
        },
        "nodes": {
          "description": "nodes provides detailed status for each control-plane node in the Pacemaker cluster.\nWhile Pacemaker supports up to 32 nodes, the limit is set to 5 (max OpenShift control-plane nodes).\nFor Two Node OpenShift with Fencing, exactly 2 nodes are expected in a healthy cluster.\nAn empty list indicates a catastrophic failure where Pacemaker reports no nodes.",
          "type": "array",
          "maxItems": 5,
          "minItems": 0,
          "items": {
            "description": "PacemakerClusterNodeStatus represents the status of a single node in the pacemaker cluster including\nthe node's conditions and the health of critical resources running on that node.",
            "type": "object",
            "required": [
              "addresses",
              "conditions",
              "fencingAgents",
              "nodeName",
              "resources"
            ],
            "properties": {
              "addresses": {
                "description": "addresses is a list of IP addresses for the node.\nPacemaker allows multiple IP addresses for Corosync communication between nodes.\nThe first address in this list is used for IP-based peer URLs for etcd membership.\nEach address must be a valid global unicast IPv4 or IPv6 address in canonical form\n(e.g., \"192.168.1.1\" not \"192.168.001.001\", or \"2001:db8::1\" not \"2001:0db8::1\").\nThis excludes loopback, link-local, and multicast addresses.",
                "type": "array",
                "maxItems": 8,
                "minItems": 1,
                "items": {
                  "description": "PacemakerNodeAddress contains information for a node's address.\nThis is similar to corev1.NodeAddress but adds validation for IP addresses.",
                  "type": "object",
                  "required": [
                    "address",
                    "type"
                  ],
                  "properties": {
                    "address": {
                      "description": "address is the node address.\nFor InternalIP, this must be a valid global unicast IPv4 or IPv6 address in canonical form.\nCanonical form means the shortest standard representation (e.g., \"192.168.1.1\" not \"192.168.001.001\",\nor \"2001:db8::1\" not \"2001:0db8::1\"). Maximum length is 39 characters (full IPv6 address).\nGlobal unicast includes private/RFC1918 addresses but excludes loopback, link-local, and multicast.",
                      "type": "string",
                      "maxLength": 39,
                      "minLength": 1,
                      "x-kubernetes-validations": [
                        {
                          "rule": "isIP(self) \u0026\u0026 ip.isCanonical(self) \u0026\u0026 ip(self).isGlobalUnicast()",
                          "message": "must be a valid global unicast IPv4 or IPv6 address in canonical form"
                        }
                      ]
                    },
                    "type": {
                      "description": "type is the type of node address.\nCurrently only \"InternalIP\" is supported.",
                      "type": "string",
                      "enum": [
                        "InternalIP"
                      ]
                    }
                  },
                  "additionalProperties": false
                },
                "x-kubernetes-list-type": "atomic"
              },
              "conditions": {
                "description": "conditions represent the observations of the node's current state.\nKnown condition types are: \"Healthy\", \"Online\", \"InService\", \"Active\", \"Ready\", \"Clean\", \"Member\",\n\"FencingAvailable\", \"FencingHealthy\".\nThe \"Healthy\" condition is an aggregate that tracks the overall health of the node.\nThe \"Online\" condition tracks whether the node is online.\nThe \"InService\" condition tracks whether the node is in service (not in maintenance mode).\nThe \"Active\" condition tracks whether the node is active (not in standby mode).\nThe \"Ready\" condition tracks whether the node is ready (not in a pending state).\nThe \"Clean\" condition tracks whether the node is in a clean (status known) state.\nThe \"Member\" condition tracks whether the node is a member of the cluster.\nThe \"FencingAvailable\" condition tracks whether this node can be fenced by at least one healthy agent.\nThe \"FencingHealthy\" condition tracks whether all fencing agents for this node are healthy.\nEach of these conditions is required, so the array must contain at least 9 items.",
                "type": "array",
                "maxItems": 16,
                "minItems": 9,
                "items": {
                  "description": "Condition contains details for one aspect of the current state of this API Resource.",
                  "type": "object",
                  "required": [
                    "lastTransitionTime",
                    "message",
                    "reason",
                    "status",
                    "type"
                  ],
                  "properties": {
                    "lastTransitionTime": {
                      "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                      "type": "string",
                      "format": "date-time"
                    },
                    "message": {
                      "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                      "type": "string",
                      "maxLength": 32768
                    },
                    "observedGeneration": {
                      "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                      "type": "integer",
                      "format": "int64",
                      "minimum": 0
                    },
                    "reason": {
                      "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                      "type": "string",
                      "maxLength": 1024,
                      "minLength": 1,
                      "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                    },
                    "status": {
                      "description": "status of the condition, one of True, False, Unknown.",
                      "type": "string",
                      "enum": [
                        "True",
                        "False",
                        "Unknown"
                      ]
                    },
                    "type": {
                      "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                      "type": "string",
                      "maxLength": 316,
                      "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                    }
                  },
                  "additionalProperties": false
                },
                "x-kubernetes-list-map-keys": [
                  "type"
                ],
                "x-kubernetes-list-type": "map",
                "x-kubernetes-validations": [
                  {
                    "rule": "self.exists(c, c.type == 'Healthy')",
                    "message": "conditions must contain a condition of type Healthy"
                  },
                  {
                    "rule": "self.exists(c, c.type == 'Online')",
                    "message": "conditions must contain a condition of type Online"
                  },
                  {
                    "rule": "self.exists(c, c.type == 'InService')",
                    "message": "conditions must contain a condition of type InService"
                  },
                  {
                    "rule": "self.exists(c, c.type == 'Active')",
                    "message": "conditions must contain a condition of type Active"
                  },
                  {
                    "rule": "self.exists(c, c.type == 'Ready')",
                    "message": "conditions must contain a condition of type Ready"
                  },
                  {
                    "rule": "self.exists(c, c.type == 'Clean')",
                    "message": "conditions must contain a condition of type Clean"
                  },
                  {
                    "rule": "self.exists(c, c.type == 'Member')",
                    "message": "conditions must contain a condition of type Member"
                  },
                  {
                    "rule": "self.exists(c, c.type == 'FencingAvailable')",
                    "message": "conditions must contain a condition of type FencingAvailable"
                  },
                  {
                    "rule": "self.exists(c, c.type == 'FencingHealthy')",
                    "message": "conditions must contain a condition of type FencingHealthy"
                  }
                ]
              },
              "fencingAgents": {
                "description": "fencingAgents contains the status of fencing agents that can fence this node.\nUnlike resources (which are scheduled to run on this node), fencing agents are mapped\nto the node they can fence (their target), not the node where monitoring operations run.\nEach fencing agent entry includes a unique name, fencing type, target node, and health conditions.\nA node is considered fence-capable if at least one fencing agent is healthy.\nExpected to have 1 fencing agent per node, but up to 8 are supported for redundancy.\nNames must be unique within this array.",
                "type": "array",
                "maxItems": 8,
                "minItems": 1,
                "items": {
                  "description": "PacemakerClusterFencingAgentStatus represents the status of a fencing agent that can fence a node.\nFencing agents are STONITH (Shoot The Other Node In The Head) devices used to isolate failed nodes.\nUnlike regular pacemaker resources, fencing agents are mapped to their target node (the node they\ncan fence), not the node where their monitoring operations are scheduled.",
                  "type": "object",
                  "required": [
                    "conditions",
                    "method",
                    "name"
                  ],
                  "properties": {
                    "conditions": {
                      "description": "conditions represent the observations of the fencing agent's current state.\nKnown condition types are: \"Healthy\", \"InService\", \"Managed\", \"Enabled\", \"Operational\",\n\"Active\", \"Started\", \"Schedulable\".\nThe \"Healthy\" condition is an aggregate that tracks the overall health of the fencing agent.\nThe \"InService\" condition tracks whether the fencing agent is in service (not in maintenance mode).\nThe \"Managed\" condition tracks whether the fencing agent is managed by pacemaker.\nThe \"Enabled\" condition tracks whether the fencing agent is enabled.\nThe \"Operational\" condition tracks whether the fencing agent is operational (not failed).\nThe \"Active\" condition tracks whether the fencing agent is active (available to be used).\nThe \"Started\" condition tracks whether the fencing agent is started.\nThe \"Schedulable\" condition tracks whether the fencing agent is schedulable (not blocked).\nEach of these conditions is required, so the array must contain at least 8 items.",
                      "type": "array",
                      "maxItems": 16,
                      "minItems": 8,
                      "items": {
                        "description": "Condition contains details for one aspect of the current state of this API Resource.",
                        "type": "object",
                        "required": [
                          "lastTransitionTime",
                          "message",
                          "reason",
                          "status",
                          "type"
                        ],
                        "properties": {
                          "lastTransitionTime": {
                            "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                            "type": "string",
                            "format": "date-time"
                          },
                          "message": {
                            "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                            "type": "string",
                            "maxLength": 32768
                          },
                          "observedGeneration": {
                            "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                            "type": "integer",
                            "format": "int64",
                            "minimum": 0
                          },
                          "reason": {
                            "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                            "type": "string",
                            "maxLength": 1024,
                            "minLength": 1,
                            "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                          },
                          "status": {
                            "description": "status of the condition, one of True, False, Unknown.",
                            "type": "string",
                            "enum": [
                              "True",
                              "False",
                              "Unknown"
                            ]
                          },
                          "type": {
                            "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                            "type": "string",
                            "maxLength": 316,
                            "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                          }
                        },
                        "additionalProperties": false
                      },
                      "x-kubernetes-list-map-keys": [
                        "type"
                      ],
                      "x-kubernetes-list-type": "map",
                      "x-kubernetes-validations": [
                        {
                          "rule": "self.exists(c, c.type == 'Healthy')",
                          "message": "conditions must contain a condition of type Healthy"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'InService')",
                          "message": "conditions must contain a condition of type InService"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Managed')",
                          "message": "conditions must contain a condition of type Managed"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Enabled')",
                          "message": "conditions must contain a condition of type Enabled"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Operational')",
                          "message": "conditions must contain a condition of type Operational"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Active')",
                          "message": "conditions must contain a condition of type Active"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Started')",
                          "message": "conditions must contain a condition of type Started"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Schedulable')",
                          "message": "conditions must contain a condition of type Schedulable"
                        }
                      ]
                    },
                    "method": {
                      "description": "method is the fencing method used by this agent.\nValid values are \"Redfish\" and \"IPMI\".\nRedfish is a standard RESTful API for server management.\nIPMI (Intelligent Platform Management Interface) is a hardware management interface.",
                      "type": "string",
                      "enum": [
                        "Redfish",
                        "IPMI"
                      ]
                    },
                    "name": {
                      "description": "name is the unique identifier for this fencing agent (e.g., \"master-0_redfish\").\nThe name must be unique within the fencingAgents array for this node.\nIt may contain alphanumeric characters, dots, hyphens, and underscores.\nMaximum length is 300 characters, providing headroom beyond the typical format of\n\u003cnode_name\u003e_\u003ctype\u003e (253 for RFC 1123 node name + 1 underscore + type).",
                      "type": "string",
                      "maxLength": 300,
                      "minLength": 1,
                      "x-kubernetes-validations": [
                        {
                          "rule": "self.matches('^[a-zA-Z0-9._-]+$')",
                          "message": "name must contain only alphanumeric characters, dots, hyphens, and underscores"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                },
                "x-kubernetes-list-map-keys": [
                  "name"
                ],
                "x-kubernetes-list-type": "map",
                "x-kubernetes-validations": [
                  {
                    "rule": "self.all(x, self.exists_one(y, x.name == y.name))",
                    "message": "fencing agent names must be unique"
                  }
                ]
              },
              "nodeName": {
                "description": "nodeName is the name of the node. This is expected to match the Kubernetes node's name, which must be a lowercase\nRFC 1123 subdomain consisting of lowercase alphanumeric characters, '-' or '.', starting and ending with\nan alphanumeric character, and be at most 253 characters in length.",
                "type": "string",
                "maxLength": 253,
                "minLength": 1,
                "x-kubernetes-validations": [
                  {
                    "rule": "!format.dns1123Subdomain().validate(self).hasValue()",
                    "message": "nodeName must be a lowercase RFC 1123 subdomain consisting of lowercase alphanumeric characters, '-' or '.', and must start and end with an alphanumeric character"
                  }
                ]
              },
              "resources": {
                "description": "resources contains the status of pacemaker resources scheduled on this node.\nEach resource entry includes the resource name and its health conditions.\nFor Two Node OpenShift with Fencing, we track Kubelet and Etcd resources per node.\nBoth resources are required to be present, so the array must contain at least 2 items.\nValid resource names are \"Kubelet\" and \"Etcd\".\nFencing agents are tracked separately in the fencingAgents field.",
                "type": "array",
                "maxItems": 8,
                "minItems": 2,
                "items": {
                  "description": "PacemakerClusterResourceStatus represents the status of a pacemaker resource scheduled on a node.\nA pacemaker resource is a unit of work managed by pacemaker. In pacemaker terminology, resources are services or\napplications that pacemaker monitors, starts, stops, and moves between nodes to maintain high availability.\nFor Two Node OpenShift with Fencing, we track two resources per node:\n  - Kubelet (the Kubernetes node agent and a prerequisite for etcd)\n  - Etcd (the distributed key-value store)\n\nFencing agents are tracked separately in the fencingAgents field because they are mapped to\ntheir target node (the node they can fence), not the node where monitoring operations are scheduled.",
                  "type": "object",
                  "required": [
                    "conditions",
                    "name"
                  ],
                  "properties": {
                    "conditions": {
                      "description": "conditions represent the observations of the resource's current state.\nKnown condition types are: \"Healthy\", \"InService\", \"Managed\", \"Enabled\", \"Operational\",\n\"Active\", \"Started\", \"Schedulable\".\nThe \"Healthy\" condition is an aggregate that tracks the overall health of the resource.\nThe \"InService\" condition tracks whether the resource is in service (not in maintenance mode).\nThe \"Managed\" condition tracks whether the resource is managed by pacemaker.\nThe \"Enabled\" condition tracks whether the resource is enabled.\nThe \"Operational\" condition tracks whether the resource is operational (not failed).\nThe \"Active\" condition tracks whether the resource is active (available to be used).\nThe \"Started\" condition tracks whether the resource is started.\nThe \"Schedulable\" condition tracks whether the resource is schedulable (not blocked).\nEach of these conditions is required, so the array must contain at least 8 items.",
                      "type": "array",
                      "maxItems": 16,
                      "minItems": 8,
                      "items": {
                        "description": "Condition contains details for one aspect of the current state of this API Resource.",
                        "type": "object",
                        "required": [
                          "lastTransitionTime",
                          "message",
                          "reason",
                          "status",
                          "type"
                        ],
                        "properties": {
                          "lastTransitionTime": {
                            "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                            "type": "string",
                            "format": "date-time"
                          },
                          "message": {
                            "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                            "type": "string",
                            "maxLength": 32768
                          },
                          "observedGeneration": {
                            "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                            "type": "integer",
                            "format": "int64",
                            "minimum": 0
                          },
                          "reason": {
                            "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                            "type": "string",
                            "maxLength": 1024,
                            "minLength": 1,
                            "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
                          },
                          "status": {
                            "description": "status of the condition, one of True, False, Unknown.",
                            "type": "string",
                            "enum": [
                              "True",
                              "False",
                              "Unknown"
                            ]
                          },
                          "type": {
                            "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                            "type": "string",
                            "maxLength": 316,
                            "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
                          }
                        },
                        "additionalProperties": false
                      },
                      "x-kubernetes-list-map-keys": [
                        "type"
                      ],
                      "x-kubernetes-list-type": "map",
                      "x-kubernetes-validations": [
                        {
                          "rule": "self.exists(c, c.type == 'Healthy')",
                          "message": "conditions must contain a condition of type Healthy"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'InService')",
                          "message": "conditions must contain a condition of type InService"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Managed')",
                          "message": "conditions must contain a condition of type Managed"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Enabled')",
                          "message": "conditions must contain a condition of type Enabled"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Operational')",
                          "message": "conditions must contain a condition of type Operational"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Active')",
                          "message": "conditions must contain a condition of type Active"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Started')",
                          "message": "conditions must contain a condition of type Started"
                        },
                        {
                          "rule": "self.exists(c, c.type == 'Schedulable')",
                          "message": "conditions must contain a condition of type Schedulable"
                        }
                      ]
                    },
                    "name": {
                      "description": "name is the name of the pacemaker resource.\nValid values are \"Kubelet\" and \"Etcd\".\nThe Kubelet resource is a prerequisite for etcd in Two Node OpenShift with Fencing deployments.\nThe Etcd resource may temporarily transition to stopped during pacemaker quorum-recovery operations.\nFencing agents are tracked separately in the node's fencingAgents field.",
                      "type": "string",
                      "enum": [
                        "Kubelet",
                        "Etcd"
                      ]
                    }
                  },
                  "additionalProperties": false
                },
                "x-kubernetes-list-map-keys": [
                  "name"
                ],
                "x-kubernetes-list-type": "map",
                "x-kubernetes-validations": [
                  {
                    "rule": "self.exists(r, r.name == 'Kubelet')",
                    "message": "resources must contain a resource named Kubelet"
                  },
                  {
                    "rule": "self.exists(r, r.name == 'Etcd')",
                    "message": "resources must contain a resource named Etcd"
                  }
                ]
              }
            },
            "additionalProperties": false
          },
          "x-kubernetes-list-map-keys": [
            "nodeName"
          ],
          "x-kubernetes-list-type": "map"
        }
      },
      "additionalProperties": false,
      "x-kubernetes-validations": [
        {
          "rule": "!has(oldSelf.lastUpdated) || self.lastUpdated \u003e= oldSelf.lastUpdated",
          "message": "lastUpdated may not be set to an earlier timestamp"
        }
      ]
    }
  },
  "x-kubernetes-validations": [
    {
      "rule": "self.metadata.name == 'cluster'",
      "message": "PacemakerCluster must be named 'cluster'"
    },
    {
      "rule": "!has(oldSelf.status) || has(self.status)",
      "message": "status may not be removed once set"
    }
  ]
}
