{
  "description": "TinkerbellMachine is the Schema for the tinkerbellmachines API.",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "TinkerbellMachineSpec defines the desired state of TinkerbellMachine.",
      "type": "object",
      "properties": {
        "bootOptions": {
          "description": "BootOptions are options that control the booting of Hardware.",
          "type": "object",
          "properties": {
            "bootMode": {
              "description": "BootMode is the type of booting that will be done.\nMust be one of \"none\", \"netboot\", or \"iso\".",
              "type": "string",
              "enum": [
                "none",
                "netboot",
                "iso"
              ]
            },
            "isoURL": {
              "description": "ISOURL is the URL of the ISO that will be one-time booted.\nA HardwareRef that contains a spec.BmcRef must be provided.\n\nThe format of the ISOURL must be http://$IP:$Port/iso/hook.iso\nThe name of the ISO file must have the .iso extension, but the name can be anything.\nThe $IP and $Port should generally point to the IP and Port of the Smee server\nas this is where the ISO patching endpoint lives.\nThe controller will append the MAC address of the hardware in the ISO URL\nright before the iso file name in the URL.\nMAC address is then used to retrieve hardware specific information such as\nIPAM info, custom kernel cmd line args and populate the worker ID for the tink worker/agent.\nFor ex. the above format would be replaced to http://$IP:$Port/iso/\u003cmacAddress\u003e/hook.iso",
              "type": "string",
              "format": "url"
            }
          },
          "additionalProperties": false
        },
        "hardwareAffinity": {
          "description": "HardwareAffinity allows filtering for hardware.",
          "type": "object",
          "properties": {
            "preferred": {
              "description": "Preferred are the preferred hardware affinity terms. Hardware matching these terms are preferred according to the\nweights provided, but are not required.",
              "type": "array",
              "items": {
                "description": "WeightedHardwareAffinityTerm is a HardwareAffinityTerm with an associated weight.  The weights of all the matched\nWeightedHardwareAffinityTerm fields are added per-hardware to find the most preferred hardware.",
                "type": "object",
                "required": [
                  "hardwareAffinityTerm",
                  "weight"
                ],
                "properties": {
                  "hardwareAffinityTerm": {
                    "description": "HardwareAffinityTerm is the term associated with the corresponding weight.",
                    "type": "object",
                    "required": [
                      "labelSelector"
                    ],
                    "properties": {
                      "labelSelector": {
                        "description": "LabelSelector is used to select for particular hardware by label.",
                        "type": "object",
                        "properties": {
                          "matchExpressions": {
                            "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                            "type": "array",
                            "items": {
                              "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                              "type": "object",
                              "required": [
                                "key",
                                "operator"
                              ],
                              "properties": {
                                "key": {
                                  "description": "key is the label key that the selector applies to.",
                                  "type": "string"
                                },
                                "operator": {
                                  "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                                  "type": "string"
                                },
                                "values": {
                                  "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  },
                                  "x-kubernetes-list-type": "atomic"
                                }
                              },
                              "additionalProperties": false
                            },
                            "x-kubernetes-list-type": "atomic"
                          },
                          "matchLabels": {
                            "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                            "type": "object",
                            "additionalProperties": {
                              "type": "string"
                            }
                          }
                        },
                        "additionalProperties": false,
                        "x-kubernetes-map-type": "atomic"
                      }
                    },
                    "additionalProperties": false
                  },
                  "weight": {
                    "description": "Weight associated with matching the corresponding hardwareAffinityTerm, in the range 1-100.",
                    "type": "integer",
                    "format": "int32",
                    "maximum": 100,
                    "minimum": 1
                  }
                },
                "additionalProperties": false
              }
            },
            "required": {
              "description": "Required are the required hardware affinity terms.  The terms are OR'd together, hardware must match one term to\nbe considered.",
              "type": "array",
              "items": {
                "description": "HardwareAffinityTerm is used to select for a particular existing hardware resource.",
                "type": "object",
                "required": [
                  "labelSelector"
                ],
                "properties": {
                  "labelSelector": {
                    "description": "LabelSelector is used to select for particular hardware by label.",
                    "type": "object",
                    "properties": {
                      "matchExpressions": {
                        "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
                        "type": "array",
                        "items": {
                          "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                          "type": "object",
                          "required": [
                            "key",
                            "operator"
                          ],
                          "properties": {
                            "key": {
                              "description": "key is the label key that the selector applies to.",
                              "type": "string"
                            },
                            "operator": {
                              "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                              "type": "string"
                            },
                            "values": {
                              "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                              "type": "array",
                              "items": {
                                "type": "string"
                              },
                              "x-kubernetes-list-type": "atomic"
                            }
                          },
                          "additionalProperties": false
                        },
                        "x-kubernetes-list-type": "atomic"
                      },
                      "matchLabels": {
                        "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      }
                    },
                    "additionalProperties": false,
                    "x-kubernetes-map-type": "atomic"
                  }
                },
                "additionalProperties": false
              }
            }
          },
          "additionalProperties": false
        },
        "hardwareName": {
          "description": "Those fields are set programmatically, but they cannot be re-constructed from \"state of the world\", so\nwe put them in spec instead of status.",
          "type": "string"
        },
        "imageLookupBaseRegistry": {
          "description": "ImageLookupBaseRegistry is the base Registry URL that is used for pulling images,\nif not set, the default will be to use ghcr.io/tinkerbell/cluster-api-provider-tinkerbell.",
          "type": "string"
        },
        "imageLookupFormat": {
          "description": "ImageLookupFormat is the URL naming format to use for machine images when\na machine does not specify. When set, this will be used for all cluster machines\nunless a machine specifies a different ImageLookupFormat. Supports substitutions\nfor {{.BaseRegistry}}, {{.OSDistro}}, {{.OSVersion}} and {{.KubernetesVersion}} with\nthe basse URL, OS distribution, OS version, and kubernetes version, respectively.\nBaseRegistry will be the value in ImageLookupBaseRegistry or ghcr.io/tinkerbell/cluster-api-provider-tinkerbell\n(the default), OSDistro will be the value in ImageLookupOSDistro or ubuntu (the default),\nOSVersion will be the value in ImageLookupOSVersion or default based on the OSDistro\n(if known), and the kubernetes version as defined by the packages produced by\nkubernetes/release: v1.13.0, v1.12.5-mybuild.1, or v1.17.3. For example, the default\nimage format of {{.BaseRegistry}}/{{.OSDistro}}-{{.OSVersion}}:{{.KubernetesVersion}}.gz will\nattempt to pull the image from that location. See also: https://golang.org/pkg/text/template/",
          "type": "string"
        },
        "imageLookupOSDistro": {
          "description": "ImageLookupOSDistro is the name of the OS distro to use when fetching machine images,\nif not set it will default to ubuntu.",
          "type": "string"
        },
        "imageLookupOSVersion": {
          "description": "ImageLookupOSVersion is the version of the OS distribution to use when fetching machine\nimages. If not set it will default based on ImageLookupOSDistro.",
          "type": "string"
        },
        "providerID": {
          "type": "string"
        },
        "templateOverride": {
          "description": "TemplateOverride overrides the default Tinkerbell template used by CAPT.\nYou can learn more about Tinkerbell templates here: https://tinkerbell.org/docs/concepts/templates/",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "status": {
      "description": "TinkerbellMachineStatus defines the observed state of TinkerbellMachine.",
      "type": "object",
      "properties": {
        "addresses": {
          "description": "Addresses contains the Tinkerbell device associated addresses.",
          "type": "array",
          "items": {
            "description": "NodeAddress contains information for the node's address.",
            "type": "object",
            "required": [
              "address",
              "type"
            ],
            "properties": {
              "address": {
                "description": "The node address.",
                "type": "string"
              },
              "type": {
                "description": "Node address type, one of Hostname, ExternalIP or InternalIP.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "errorMessage": {
          "description": "ErrorMessage will be set in the event that there is a terminal problem\nreconciling the Machine and will contain a more verbose string suitable\nfor logging and human consumption.\n\nThis field should not be set for transitive errors that a controller\nfaces that are expected to be fixed automatically over\ntime (like service outages), but instead indicate that something is\nfundamentally wrong with the Machine's spec or the configuration of\nthe controller, and that manual intervention is required. Examples\nof terminal errors would be invalid combinations of settings in the\nspec, values that are unsupported by the controller, or the\nresponsible controller itself being critically misconfigured.\n\nAny transient errors that occur during the reconciliation of Machines\ncan be added as events to the Machine object and/or logged in the\ncontroller's output.",
          "type": "string"
        },
        "errorReason": {
          "description": "Any transient errors that occur during the reconciliation of Machines\ncan be added as events to the Machine object and/or logged in the\ncontroller's output.",
          "type": "string"
        },
        "instanceStatus": {
          "description": "InstanceStatus is the status of the Tinkerbell device instance for this machine.",
          "type": "integer"
        },
        "ready": {
          "description": "Ready is true when the provider resource is ready.",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    }
  }
}
