{
  "description": "SecretRotator is the Schema for the secretrotators API",
  "type": "object",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "SecretRotatorSpec defines the desired state of SecretRotator",
      "type": "object",
      "required": [
        "namespaceSelector"
      ],
      "properties": {
        "artifactorySubdomains": {
          "description": "ArtifactorySubdomains holds a list of Artifactory subdomain names.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "artifactoryUrl": {
          "description": "ArtifactoryUrl, URL of Artifactory",
          "type": "string"
        },
        "awsRegion": {
          "description": "AwsRegion holding aws region name",
          "type": "string"
        },
        "generatedSecrets": {
          "description": "GeneratedSecrets defines the secrets to be created",
          "type": "array",
          "items": {
            "description": "GeneratedSecret defines an individual secret to be created",
            "type": "object",
            "required": [
              "secretName",
              "secretType"
            ],
            "properties": {
              "scope": {
                "description": "Scope defines the scope of the secret (optional)",
                "type": "string"
              },
              "secretName": {
                "description": "SecretName holding name of the secret",
                "type": "string"
              },
              "secretType": {
                "description": "SecretType specifies the type of secret (docker or generic)",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "namespaceSelector": {
          "description": "NamespaceSelector holding SecretRotatorList of the namespaces",
          "type": "object",
          "properties": {
            "matchExpressions": {
              "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
              "type": "array",
              "items": {
                "description": "A label selector requirement is a selector that contains values, a key, and an operator that\nrelates the key and values.",
                "type": "object",
                "required": [
                  "key",
                  "operator"
                ],
                "properties": {
                  "key": {
                    "description": "key is the label key that the selector applies to.",
                    "type": "string"
                  },
                  "operator": {
                    "description": "operator represents a key's relationship to a set of values.\nValid operators are In, NotIn, Exists and DoesNotExist.",
                    "type": "string"
                  },
                  "values": {
                    "description": "values is an array of string values. If the operator is In or NotIn,\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\nthe values array must be empty. This array is replaced during a strategic\nmerge patch.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "matchLabels": {
              "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\nmap is equivalent to an element of matchExpressions, whose key field is \"key\", the\noperator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false,
          "x-kubernetes-map-type": "atomic"
        },
        "refreshTime": {
          "description": "RefreshInterval The time in which the controller should reconcile it's objects and recheck namespaces for labels.",
          "type": "string"
        },
        "secretMetadata": {
          "description": "INSERT ADDITIONAL SPEC FIELDS - desired state of cluster\nImportant: Run \"make\" to regenerate code after modifying this file\nThe spec for the ExternalSecrets to be created\nThe metadata of the external secrets to be created",
          "type": "object",
          "properties": {
            "annotations": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "labels": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "additionalProperties": false
        },
        "secretName": {
          "description": "SecretName holding the name of a single Docker secret\nSecretName is optional in 2.x.x and will be deprecated in the next upcoming releases\nAdded for backward compatibility with 1.x.x\nIf specified, a Docker secret with this name is created in addition to any secrets defined in generatedSecrets.",
          "type": "string"
        },
        "security": {
          "description": "Security holding tls/ssl certificates details",
          "type": "object",
          "properties": {
            "certificateSecretName": {
              "type": "string"
            },
            "enabled": {
              "type": "boolean",
              "default": false
            },
            "insecureSkipVerify": {
              "type": "boolean"
            },
            "secretNamespace": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "serviceAccount": {
          "description": "Each target user's ServiceAccount, restricting access to only the specified service accounts and ensuring the role is limited to the jfrog operator service account.",
          "type": "object",
          "properties": {
            "name": {
              "description": "Name of the service account",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace of the service account",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "status": {
      "description": "SecretRotatorStatus defines the observed state of SecretRotator",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Conditions store the status conditions of the Memcached instances",
          "type": "array",
          "items": {
            "description": "Condition contains details for one aspect of the current state of this API Resource.",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "message",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "lastTransitionTime is the last time the condition transitioned from one status to another.\nThis should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "message is a human readable message indicating details about the transition.\nThis may be an empty string.",
                "type": "string",
                "maxLength": 32768
              },
              "observedGeneration": {
                "description": "observedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "type": "integer",
                "format": "int64",
                "minimum": 0
              },
              "reason": {
                "description": "reason contains a programmatic identifier indicating the reason for the condition's last transition.\nProducers of specific condition types may define expected values and meanings for this field,\nand whether the values are considered a guaranteed API.\nThe value should be a CamelCase string.\nThis field may not be empty.",
                "type": "string",
                "maxLength": 1024,
                "minLength": 1,
                "pattern": "^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$"
              },
              "status": {
                "description": "status of the condition, one of True, False, Unknown.",
                "type": "string",
                "enum": [
                  "True",
                  "False",
                  "Unknown"
                ]
              },
              "type": {
                "description": "type of condition in CamelCase or in foo.example.com/CamelCase.",
                "type": "string",
                "maxLength": 316,
                "pattern": "^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"
              }
            },
            "additionalProperties": false
          }
        },
        "failedNamespaces": {
          "description": "Failed namespaces are the namespaces that failed to apply an ExternalSecret",
          "type": "array",
          "items": {
            "description": "SecretNamespaceFailure represents a failed namespace deployment and it's reason.",
            "type": "object",
            "required": [
              "namespace"
            ],
            "properties": {
              "namespace": {
                "description": "Namespace is the namespace that failed when trying to apply an ExternalSecret",
                "type": "string"
              },
              "reason": {
                "description": "Reason is why the ExternalSecret failed to apply to the namespace",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "provisionedNamespaces": {
          "description": "ProvisionedNamespaces are the namespaces where the ClusterExternalSecret has secrets",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "secretManagedByNamespaces": {
          "description": "SecretManagedByNamespaces are the secrets in the namespaces that are managed by the SecretRotator",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "additionalProperties": false
    }
  }
}
