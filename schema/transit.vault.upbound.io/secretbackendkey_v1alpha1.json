{
  "description": "SecretBackendKey is the Schema for the SecretBackendKeys API. Create an Encryption Keyring on a Transit Secret Backend for Vault.",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object.\nServers should convert recognized schemas to the latest internal value, and\nmay reject unrecognized values.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents.\nServers may infer this from the endpoint the client submits requests to.\nCannot be updated.\nIn CamelCase.\nMore info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "type": "object"
    },
    "spec": {
      "description": "SecretBackendKeySpec defines the desired state of SecretBackendKey",
      "type": "object",
      "required": [
        "forProvider"
      ],
      "properties": {
        "deletionPolicy": {
          "description": "DeletionPolicy specifies what will happen to the underlying external\nwhen this managed resource is deleted - either \"Delete\" or \"Orphan\" the\nexternal resource.\nThis field is planned to be deprecated in favor of the ManagementPolicies\nfield in a future release. Currently, both could be set independently and\nnon-default values would be honored if the feature flag is enabled.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223",
          "type": "string",
          "default": "Delete",
          "enum": [
            "Orphan",
            "Delete"
          ]
        },
        "forProvider": {
          "type": "object",
          "properties": {
            "allowPlaintextBackup": {
              "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\nIf set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled.",
              "type": "boolean"
            },
            "autoRotatePeriod": {
              "description": "Amount of seconds the key should live before being automatically rotated.\nA value of 0 disables automatic rotation for the key.\nAmount of seconds the key should live before being automatically rotated. A value of 0 disables automatic rotation for the key.",
              "type": "number"
            },
            "backend": {
              "description": "The path the transit secret backend is mounted at, with no leading or trailing /s.\nThe Transit secret backend the resource belongs to.",
              "type": "string"
            },
            "backendRef": {
              "description": "Reference to a Mount in vault to populate backend.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "backendSelector": {
              "description": "Selector for a Mount in vault to populate backend.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "convergentEncryption": {
              "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires derived to be set to true.\nWhether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires derived to be set to true.",
              "type": "boolean"
            },
            "deletionAllowed": {
              "description": "Specifies if the keyring is allowed to be deleted.\nSpecifies if the key is allowed to be deleted.",
              "type": "boolean"
            },
            "derived": {
              "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\nSpecifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.",
              "type": "boolean"
            },
            "exportable": {
              "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\nEnables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled.",
              "type": "boolean"
            },
            "hybridKeyTypeEc": {
              "description": "The elliptic curve algorithm to use for hybrid signatures.\nSupported key types are ecdsa-p256, ecdsa-p384, ecdsa-p521, and ed25519.\nThe elliptic curve algorithm to use for hybrid signatures. Supported key types are `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, and `ed25519`.",
              "type": "string"
            },
            "hybridKeyTypePqc": {
              "description": "The post-quantum algorithm to use for hybrid signatures.\nCurrently, ML-DSA is the only supported key type.\nThe post-quantum algorithm to use for hybrid signatures. Currently, ML-DSA is the only supported key type.",
              "type": "string"
            },
            "keySize": {
              "description": "The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes.\nThe key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC; this value must be between 32 and 512.",
              "type": "number"
            },
            "minDecryptionVersion": {
              "description": "Minimum key version to use for decryption.\nMinimum key version to use for decryption.",
              "type": "number"
            },
            "minEncryptionVersion": {
              "description": "Minimum key version to use for encryption\nMinimum key version to use for encryption",
              "type": "number"
            },
            "name": {
              "description": "The name to identify this key within the backend. Must be unique within the backend.\nName of the encryption key to create.",
              "type": "string"
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "parameterSet": {
              "description": "The parameter set to use for ML-DSA or SLH-DSA. Required for\nML-DSA, hybrid, and SLH-DSA keys.\nValid values for ML-DSA are 44, 65, and 87.\nValid values for SLH-DSA are slh-dsa-sha2-128s, slh-dsa-shake-128s, slh-dsa-sha2-128f, slh-dsa-shake-128, slh-dsa-sha2-192s,\nslh-dsa-shake-192s, slh-dsa-sha2-192f, slh-dsa-shake-192f, slh-dsa-sha2-256s, slh-dsa-shake-256s,\nslh-dsa-sha2-256f, and slh-dsa-shake-256f.\nThe parameter set to use for ML-DSA. Required for ML-DSA and hybrid keys.  Valid values for ML-DSA are `44`, `65`, and `87`. Valid values for SLH-DSA are `slh-dsa-sha2-128s`, `slh-dsa-shake-128s`, `slh-dsa-sha2-128f`, `slh-dsa-shake-128`, `slh-dsa-sha2-192s`, `slh-dsa-shake-192s`, `slh-dsa-sha2-192f`, `slh-dsa-shake-192f`, `slh-dsa-sha2-256s`, `slh-dsa-shake-256s`, `slh-dsa-sha2-256f`, and `slh-dsa-shake-256f`.",
              "type": "string"
            },
            "type": {
              "description": "Specifies the type of key to create. The currently-supported types are: aes128-gcm96, aes256-gcm96 (default), chacha20-poly1305, ed25519, ecdsa-p256, ecdsa-p384, ecdsa-p521, hmac, rsa-2048, rsa-3072, rsa-4096, managed_key, aes128-cmac, aes192-cmac, aes256-cmac, ml-dsa, hybrid, and slh-dsa.\nSpecifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `hmac`, `rsa-2048`, `rsa-3072`, `rsa-4096`, `managed_key`, `aes128-cmac`, `aes192-cmac`, `aes256-cmac`, `ml-dsa`, `hybrid`, and `slh-dsa`.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "initProvider": {
          "description": "THIS IS A BETA FIELD. It will be honored\nunless the Management Policies feature flag is disabled.\nInitProvider holds the same fields as ForProvider, with the exception\nof Identifier and other resource reference fields. The fields that are\nin InitProvider are merged into ForProvider when the resource is created.\nThe same fields are also added to the terraform ignore_changes hook, to\navoid updating them after creation. This is useful for fields that are\nrequired on creation, but we do not desire to update them after creation,\nfor example because of an external controller is managing them, like an\nautoscaler.",
          "type": "object",
          "properties": {
            "allowPlaintextBackup": {
              "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\nIf set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled.",
              "type": "boolean"
            },
            "autoRotatePeriod": {
              "description": "Amount of seconds the key should live before being automatically rotated.\nA value of 0 disables automatic rotation for the key.\nAmount of seconds the key should live before being automatically rotated. A value of 0 disables automatic rotation for the key.",
              "type": "number"
            },
            "backend": {
              "description": "The path the transit secret backend is mounted at, with no leading or trailing /s.\nThe Transit secret backend the resource belongs to.",
              "type": "string"
            },
            "backendRef": {
              "description": "Reference to a Mount in vault to populate backend.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "backendSelector": {
              "description": "Selector for a Mount in vault to populate backend.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference\nas the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            "convergentEncryption": {
              "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires derived to be set to true.\nWhether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires derived to be set to true.",
              "type": "boolean"
            },
            "deletionAllowed": {
              "description": "Specifies if the keyring is allowed to be deleted.\nSpecifies if the key is allowed to be deleted.",
              "type": "boolean"
            },
            "derived": {
              "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\nSpecifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.",
              "type": "boolean"
            },
            "exportable": {
              "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\nEnables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled.",
              "type": "boolean"
            },
            "hybridKeyTypeEc": {
              "description": "The elliptic curve algorithm to use for hybrid signatures.\nSupported key types are ecdsa-p256, ecdsa-p384, ecdsa-p521, and ed25519.\nThe elliptic curve algorithm to use for hybrid signatures. Supported key types are `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, and `ed25519`.",
              "type": "string"
            },
            "hybridKeyTypePqc": {
              "description": "The post-quantum algorithm to use for hybrid signatures.\nCurrently, ML-DSA is the only supported key type.\nThe post-quantum algorithm to use for hybrid signatures. Currently, ML-DSA is the only supported key type.",
              "type": "string"
            },
            "keySize": {
              "description": "The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes.\nThe key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC; this value must be between 32 and 512.",
              "type": "number"
            },
            "minDecryptionVersion": {
              "description": "Minimum key version to use for decryption.\nMinimum key version to use for decryption.",
              "type": "number"
            },
            "minEncryptionVersion": {
              "description": "Minimum key version to use for encryption\nMinimum key version to use for encryption",
              "type": "number"
            },
            "name": {
              "description": "The name to identify this key within the backend. Must be unique within the backend.\nName of the encryption key to create.",
              "type": "string"
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "parameterSet": {
              "description": "The parameter set to use for ML-DSA or SLH-DSA. Required for\nML-DSA, hybrid, and SLH-DSA keys.\nValid values for ML-DSA are 44, 65, and 87.\nValid values for SLH-DSA are slh-dsa-sha2-128s, slh-dsa-shake-128s, slh-dsa-sha2-128f, slh-dsa-shake-128, slh-dsa-sha2-192s,\nslh-dsa-shake-192s, slh-dsa-sha2-192f, slh-dsa-shake-192f, slh-dsa-sha2-256s, slh-dsa-shake-256s,\nslh-dsa-sha2-256f, and slh-dsa-shake-256f.\nThe parameter set to use for ML-DSA. Required for ML-DSA and hybrid keys.  Valid values for ML-DSA are `44`, `65`, and `87`. Valid values for SLH-DSA are `slh-dsa-sha2-128s`, `slh-dsa-shake-128s`, `slh-dsa-sha2-128f`, `slh-dsa-shake-128`, `slh-dsa-sha2-192s`, `slh-dsa-shake-192s`, `slh-dsa-sha2-192f`, `slh-dsa-shake-192f`, `slh-dsa-sha2-256s`, `slh-dsa-shake-256s`, `slh-dsa-sha2-256f`, and `slh-dsa-shake-256f`.",
              "type": "string"
            },
            "type": {
              "description": "Specifies the type of key to create. The currently-supported types are: aes128-gcm96, aes256-gcm96 (default), chacha20-poly1305, ed25519, ecdsa-p256, ecdsa-p384, ecdsa-p521, hmac, rsa-2048, rsa-3072, rsa-4096, managed_key, aes128-cmac, aes192-cmac, aes256-cmac, ml-dsa, hybrid, and slh-dsa.\nSpecifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `hmac`, `rsa-2048`, `rsa-3072`, `rsa-4096`, `managed_key`, `aes128-cmac`, `aes192-cmac`, `aes256-cmac`, `ml-dsa`, `hybrid`, and `slh-dsa`.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "managementPolicies": {
          "description": "THIS IS A BETA FIELD. It is on by default but can be opted out\nthrough a Crossplane feature flag.\nManagementPolicies specify the array of actions Crossplane is allowed to\ntake on the managed and external resources.\nThis field is planned to replace the DeletionPolicy field in a future\nrelease. Currently, both could be set independently and non-default\nvalues would be honored if the feature flag is enabled. If both are\ncustom, the DeletionPolicy field will be ignored.\nSee the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223\nand this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md",
          "type": "array",
          "default": [
            "*"
          ],
          "items": {
            "description": "A ManagementAction represents an action that the Crossplane controllers\ncan take on an external resource.",
            "type": "string",
            "enum": [
              "Observe",
              "Create",
              "Update",
              "Delete",
              "LateInitialize",
              "*"
            ]
          }
        },
        "providerConfigRef": {
          "description": "ProviderConfigReference specifies how the provider that will be used to\ncreate, observe, update, and delete this managed resource should be\nconfigured.",
          "type": "object",
          "default": {
            "name": "default"
          },
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "Name of the referenced object.",
              "type": "string"
            },
            "policy": {
              "description": "Policies for referencing.",
              "type": "object",
              "properties": {
                "resolution": {
                  "description": "Resolution specifies whether resolution of this reference is required.\nThe default is 'Required', which means the reconcile will fail if the\nreference cannot be resolved. 'Optional' means this reference will be\na no-op if it cannot be resolved.",
                  "type": "string",
                  "default": "Required",
                  "enum": [
                    "Required",
                    "Optional"
                  ]
                },
                "resolve": {
                  "description": "Resolve specifies when this reference should be resolved. The default\nis 'IfNotPresent', which will attempt to resolve the reference only when\nthe corresponding field is not present. Use 'Always' to resolve the\nreference on every reconcile.",
                  "type": "string",
                  "enum": [
                    "Always",
                    "IfNotPresent"
                  ]
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "writeConnectionSecretToRef": {
          "description": "WriteConnectionSecretToReference specifies the namespace and name of a\nSecret to which any connection details for this managed resource should\nbe written. Connection details frequently include the endpoint, username,\nand password required to connect to the managed resource.",
          "type": "object",
          "required": [
            "name",
            "namespace"
          ],
          "properties": {
            "name": {
              "description": "Name of the secret.",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace of the secret.",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false,
      "x-kubernetes-validations": [
        {
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) \u0026\u0026 has(self.initProvider.name))",
          "message": "spec.forProvider.name is a required parameter"
        }
      ]
    },
    "status": {
      "description": "SecretBackendKeyStatus defines the observed state of SecretBackendKey.",
      "type": "object",
      "properties": {
        "atProvider": {
          "type": "object",
          "properties": {
            "allowPlaintextBackup": {
              "description": "Enables taking backup of entire keyring in the plaintext format. Once set, this cannot be disabled.\nIf set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled.",
              "type": "boolean"
            },
            "autoRotatePeriod": {
              "description": "Amount of seconds the key should live before being automatically rotated.\nA value of 0 disables automatic rotation for the key.\nAmount of seconds the key should live before being automatically rotated. A value of 0 disables automatic rotation for the key.",
              "type": "number"
            },
            "backend": {
              "description": "The path the transit secret backend is mounted at, with no leading or trailing /s.\nThe Transit secret backend the resource belongs to.",
              "type": "string"
            },
            "convergentEncryption": {
              "description": "Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires derived to be set to true.\nWhether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires derived to be set to true.",
              "type": "boolean"
            },
            "deletionAllowed": {
              "description": "Specifies if the keyring is allowed to be deleted.\nSpecifies if the key is allowed to be deleted.",
              "type": "boolean"
            },
            "derived": {
              "description": "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.\nSpecifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.",
              "type": "boolean"
            },
            "exportable": {
              "description": "Enables keys to be exportable. This allows for all valid private keys in the keyring to be exported. Once set, this cannot be disabled.\nEnables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled.",
              "type": "boolean"
            },
            "hybridKeyTypeEc": {
              "description": "The elliptic curve algorithm to use for hybrid signatures.\nSupported key types are ecdsa-p256, ecdsa-p384, ecdsa-p521, and ed25519.\nThe elliptic curve algorithm to use for hybrid signatures. Supported key types are `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, and `ed25519`.",
              "type": "string"
            },
            "hybridKeyTypePqc": {
              "description": "The post-quantum algorithm to use for hybrid signatures.\nCurrently, ML-DSA is the only supported key type.\nThe post-quantum algorithm to use for hybrid signatures. Currently, ML-DSA is the only supported key type.",
              "type": "string"
            },
            "id": {
              "type": "string"
            },
            "keySize": {
              "description": "The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes.\nThe key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC; this value must be between 32 and 512.",
              "type": "number"
            },
            "keys": {
              "description": "List of key versions in the keyring. This attribute is zero-indexed and will contain a map of values depending on the type of the encryption key.\nList of key versions in the keyring.",
              "type": "array",
              "items": {
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              }
            },
            "latestVersion": {
              "description": "Latest key version available. This value is 1-indexed, so if latest_version is 1, then the key's information can be referenced from keys by selecting element 0\nLatest key version in use in the keyring",
              "type": "number"
            },
            "minAvailableVersion": {
              "description": "Minimum key version available for use. If keys have been archived by increasing min_decryption_version, this attribute will reflect that change.\nMinimum key version available for use.",
              "type": "number"
            },
            "minDecryptionVersion": {
              "description": "Minimum key version to use for decryption.\nMinimum key version to use for decryption.",
              "type": "number"
            },
            "minEncryptionVersion": {
              "description": "Minimum key version to use for encryption\nMinimum key version to use for encryption",
              "type": "number"
            },
            "name": {
              "description": "The name to identify this key within the backend. Must be unique within the backend.\nName of the encryption key to create.",
              "type": "string"
            },
            "namespace": {
              "description": "The namespace to provision the resource in.\nThe value should not contain leading or trailing forward slashes.\nThe namespace is always relative to the provider's configured namespace.\nAvailable only for Vault Enterprise.\nTarget namespace. (requires Enterprise)",
              "type": "string"
            },
            "parameterSet": {
              "description": "The parameter set to use for ML-DSA or SLH-DSA. Required for\nML-DSA, hybrid, and SLH-DSA keys.\nValid values for ML-DSA are 44, 65, and 87.\nValid values for SLH-DSA are slh-dsa-sha2-128s, slh-dsa-shake-128s, slh-dsa-sha2-128f, slh-dsa-shake-128, slh-dsa-sha2-192s,\nslh-dsa-shake-192s, slh-dsa-sha2-192f, slh-dsa-shake-192f, slh-dsa-sha2-256s, slh-dsa-shake-256s,\nslh-dsa-sha2-256f, and slh-dsa-shake-256f.\nThe parameter set to use for ML-DSA. Required for ML-DSA and hybrid keys.  Valid values for ML-DSA are `44`, `65`, and `87`. Valid values for SLH-DSA are `slh-dsa-sha2-128s`, `slh-dsa-shake-128s`, `slh-dsa-sha2-128f`, `slh-dsa-shake-128`, `slh-dsa-sha2-192s`, `slh-dsa-shake-192s`, `slh-dsa-sha2-192f`, `slh-dsa-shake-192f`, `slh-dsa-sha2-256s`, `slh-dsa-shake-256s`, `slh-dsa-sha2-256f`, and `slh-dsa-shake-256f`.",
              "type": "string"
            },
            "supportsDecryption": {
              "description": "Whether or not the key supports decryption, based on key type.\nWhether or not the key supports decryption, based on key type.",
              "type": "boolean"
            },
            "supportsDerivation": {
              "description": "Whether or not the key supports derivation, based on key type.\nWhether or not the key supports derivation, based on key type.",
              "type": "boolean"
            },
            "supportsEncryption": {
              "description": "Whether or not the key supports encryption, based on key type.\nWhether or not the key supports encryption, based on key type.",
              "type": "boolean"
            },
            "supportsSigning": {
              "description": "Whether or not the key supports signing, based on key type.\nWhether or not the key supports signing, based on key type.",
              "type": "boolean"
            },
            "type": {
              "description": "Specifies the type of key to create. The currently-supported types are: aes128-gcm96, aes256-gcm96 (default), chacha20-poly1305, ed25519, ecdsa-p256, ecdsa-p384, ecdsa-p521, hmac, rsa-2048, rsa-3072, rsa-4096, managed_key, aes128-cmac, aes192-cmac, aes256-cmac, ml-dsa, hybrid, and slh-dsa.\nSpecifies the type of key to create. The currently-supported types are: `aes128-gcm96`, `aes256-gcm96` (default), `chacha20-poly1305`, `ed25519`, `ecdsa-p256`, `ecdsa-p384`, `ecdsa-p521`, `hmac`, `rsa-2048`, `rsa-3072`, `rsa-4096`, `managed_key`, `aes128-cmac`, `aes192-cmac`, `aes256-cmac`, `ml-dsa`, `hybrid`, and `slh-dsa`.",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "conditions": {
          "description": "Conditions of the resource.",
          "type": "array",
          "items": {
            "description": "A Condition that may apply to a resource.",
            "type": "object",
            "required": [
              "lastTransitionTime",
              "reason",
              "status",
              "type"
            ],
            "properties": {
              "lastTransitionTime": {
                "description": "LastTransitionTime is the last time this condition transitioned from one\nstatus to another.",
                "type": "string",
                "format": "date-time"
              },
              "message": {
                "description": "A Message containing details about this condition's last transition from\none status to another, if any.",
                "type": "string"
              },
              "observedGeneration": {
                "description": "ObservedGeneration represents the .metadata.generation that the condition was set based upon.\nFor instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date\nwith respect to the current state of the instance.",
                "type": "integer",
                "format": "int64"
              },
              "reason": {
                "description": "A Reason for this condition's last transition from one status to another.",
                "type": "string"
              },
              "status": {
                "description": "Status of this condition; is it currently True, False, or Unknown?",
                "type": "string"
              },
              "type": {
                "description": "Type of this condition. At most one of each condition type may apply to\na resource at any point in time.",
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the latest metadata.generation\nwhich resulted in either a ready state, or stalled due to error\nit can not recover from without human intervention.",
          "type": "integer",
          "format": "int64"
        }
      },
      "additionalProperties": false
    }
  }
}
